<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è±†åŒ…AIè¯­éŸ³é€šè¯ - æµè§ˆå™¨ç‰ˆ</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .app-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 600px;
        }

        .app-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .app-title {
            font-size: 2.5em;
            color: #333;
            margin-bottom: 10px;
        }

        .app-subtitle {
            color: #666;
            font-size: 1.1em;
        }

        .connection-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
        }

        .section-title {
            font-size: 1.3em;
            color: #333;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .config-group {
            margin-bottom: 20px;
        }

        .config-label {
            display: block;
            font-weight: 600;
            color: #555;
            margin-bottom: 8px;
        }

        .config-input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .config-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .status-indicator {
            padding: 12px 20px;
            border-radius: 10px;
            font-weight: 600;
            text-align: center;
            margin: 15px 0;
            transition: all 0.3s;
        }

        .status-disconnected {
            background: #fee;
            color: #c33;
            border: 2px solid #fcc;
        }

        .status-connecting {
            background: #fff3cd;
            color: #856404;
            border: 2px solid #ffeaa7;
        }

        .status-connected {
            background: #d4edda;
            color: #155724;
            border: 2px solid #c3e6cb;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            flex: 1;
            min-width: 120px;
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-danger {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }

        .btn-success {
            background: linear-gradient(45deg, #51cf66, #40c057);
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(81, 207, 102, 0.4);
        }

        .voice-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
        }

        .voice-controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .voice-button {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: none;
            font-size: 3em;
            cursor: pointer;
            transition: all 0.3s;
            margin: 0 auto;
            position: relative;
            overflow: hidden;
        }

        .voice-button.recording {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
            animation: pulse 1.5s infinite;
        }

        .voice-button.idle {
            background: linear-gradient(45deg, #51cf66, #40c057);
            color: white;
        }

        .voice-button:disabled {
            background: #ccc;
            color: #999;
            cursor: not-allowed;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .volume-display {
            text-align: center;
            margin: 20px 0;
        }

        .volume-bar-container {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .volume-bar {
            height: 100%;
            background: linear-gradient(90deg, #51cf66, #ffd43b, #ff6b6b);
            width: 0%;
            transition: width 0.1s;
        }

        .message-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
        }

        .message-input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .message-input {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 16px;
        }

        .conversation-display {
            background: white;
            border-radius: 10px;
            padding: 20px;
            min-height: 200px;
            max-height: 300px;
            overflow-y: auto;
            border: 2px solid #e9ecef;
        }

        .message {
            margin-bottom: 15px;
            padding: 10px 15px;
            border-radius: 10px;
            max-width: 80%;
        }

        .message.user {
            background: #667eea;
            color: white;
            margin-left: auto;
        }

        .message.ai {
            background: #e9ecef;
            color: #333;
        }

        .message-time {
            font-size: 0.8em;
            opacity: 0.7;
            margin-top: 5px;
        }

        .log-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
        }

        .log-display {
            background: #2d3748;
            color: #e2e8f0;
            border-radius: 10px;
            padding: 20px;
            height: 250px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
        }

        .log-controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }

        .floating-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: 600;
            z-index: 1000;
            transition: all 0.3s;
        }

        .floating-indicator.hidden {
            opacity: 0;
            transform: translateY(-20px);
        }

        .config-status {
            font-size: 0.8em;
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: normal;
            margin-left: 10px;
        }

        .config-status.saved {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .config-status.unsaved {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .audio-device-section {
            background: #f1f3f4;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #e0e0e0;
        }

        .device-row {
            margin-bottom: 15px;
        }

        .device-row:last-child {
            margin-bottom: 0;
        }

        .device-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .device-label {
            min-width: 100px;
            font-weight: 600;
            color: #555;
            font-size: 14px;
        }

        .device-select {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        .device-select:focus {
            outline: none;
            border-color: #667eea;
        }

        .device-select:disabled {
            background: #f8f9fa;
            color: #6c757d;
            cursor: not-allowed;
        }

        .btn-small {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 40px;
        }

        .btn-small:hover:not(:disabled) {
            transform: translateY(-1px);
        }

        .btn-small:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        @media (max-width: 768px) {
            .app-container {
                width: 95%;
                padding: 20px;
            }

            .button-group {
                flex-direction: column;
            }

            .btn {
                min-width: auto;
            }

            .voice-button {
                width: 100px;
                height: 100px;
                font-size: 2.5em;
            }

            .device-group {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }

            .device-label {
                min-width: auto;
                font-size: 13px;
            }

            .audio-device-section {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="app-header">
            <h1 class="app-title">ğŸ¤– è±†åŒ…AIè¯­éŸ³é€šè¯</h1>
            <p class="app-subtitle">é«˜è´¨é‡å®æ—¶è¯­éŸ³å¯¹è¯ä½“éªŒ</p>
        </div>

        <!-- è¿æ¥é…ç½® -->
        <div class="connection-section">
            <h3 class="section-title">ğŸ”§ è¿æ¥é…ç½® <span id="configStatus" class="config-status"></span></h3>
            
            <div class="config-group">
                <label class="config-label">ä»£ç†æœåŠ¡å™¨åœ°å€</label>
                <input type="text" id="proxyUrl" class="config-input" value="ws://localhost:8765" placeholder="ws://localhost:8765">
            </div>
            
            <div class="config-group">
                <label class="config-label">App ID</label>
                <input type="text" id="appId" class="config-input" placeholder="è¯·è¾“å…¥ç«å±±å¼•æ“App ID">
            </div>
            
            <div class="config-group">
                <label class="config-label">Access Token</label>
                <input type="password" id="accessToken" class="config-input" placeholder="è¯·è¾“å…¥ç«å±±å¼•æ“Access Token">
            </div>

            <div id="connectionStatus" class="status-indicator status-disconnected">
                ğŸ”´ æœªè¿æ¥
            </div>

            <div class="button-group">
                <button id="connectBtn" class="btn btn-primary" onclick="connect()">è¿æ¥</button>
                <button id="disconnectBtn" class="btn btn-danger" onclick="disconnect()" disabled>æ–­å¼€è¿æ¥</button>
            </div>
            
            <div class="button-group" style="margin-top: 10px;">
                <button class="btn btn-success" onclick="saveConfiguration()" title="æ‰‹åŠ¨ä¿å­˜å½“å‰é…ç½®">ğŸ’¾ ä¿å­˜é…ç½®</button>
                <button class="btn btn-danger" onclick="clearConfiguration()" title="æ¸…é™¤æ‰€æœ‰ä¿å­˜çš„é…ç½®">ğŸ—‘ï¸ æ¸…é™¤é…ç½®</button>
            </div>
        </div>

        <!-- è¯­éŸ³æ§åˆ¶ -->
        <div class="voice-section">
            <h3 class="section-title">ğŸ¤ è¯­éŸ³å¯¹è¯</h3>
            
            <!-- éŸ³é¢‘è®¾å¤‡é€‰æ‹© -->
            <div class="audio-device-section">
                <div class="device-row">
                    <div class="device-group">
                        <label class="device-label">ğŸ¤ éº¦å…‹é£è®¾å¤‡</label>
                        <select id="microphoneSelect" class="device-select">
                            <option value="">é€‰æ‹©éº¦å…‹é£...</option>
                        </select>
                        <button class="btn-small btn-primary" onclick="refreshAudioDevices()" title="åˆ·æ–°è®¾å¤‡åˆ—è¡¨">ğŸ”„</button>
                    </div>
                </div>
                
                <div class="device-row">
                    <div class="device-group">
                        <label class="device-label">ğŸ”Š æ‰¬å£°å™¨è®¾å¤‡</label>
                        <select id="speakerSelect" class="device-select">
                            <option value="">é€‰æ‹©æ‰¬å£°å™¨...</option>
                        </select>
                        <button class="btn-small btn-success" onclick="testSpeaker()" title="æµ‹è¯•æ‰¬å£°å™¨">ğŸ””</button>
                    </div>
                </div>
            </div>
            
            <div class="voice-controls">
                <button id="voiceButton" class="voice-button idle" onclick="toggleRecording()" disabled>
                    ğŸ¤
                </button>
                
                <div class="volume-display">
                    <div>éŸ³é‡: <span id="volumeText">0%</span></div>
                    <div class="volume-bar-container">
                        <div id="volumeBar" class="volume-bar"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- æ–‡æœ¬æ¶ˆæ¯ -->
        <div class="message-section">
            <h3 class="section-title">ğŸ’¬ å¯¹è¯è®°å½•</h3>
            
            <div class="message-input-group">
                <input type="text" id="messageInput" class="message-input" placeholder="è¾“å…¥æ–‡æœ¬æ¶ˆæ¯..." value="ä½ å¥½">
                <button class="btn btn-primary" onclick="sendMessage()">å‘é€</button>
            </div>
            
            <div id="conversationDisplay" class="conversation-display"></div>
        </div>

        <!-- æ—¥å¿— -->
        <div class="log-section">
            <h3 class="section-title">ğŸ“‹ ç³»ç»Ÿæ—¥å¿—</h3>
            <div id="logDisplay" class="log-display"></div>
            <div class="log-controls">
                <button class="btn btn-primary" onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
                <button class="btn btn-primary" onclick="toggleAutoScroll()">
                    <span id="autoScrollText">è‡ªåŠ¨æ»šåŠ¨: å¼€</span>
                </button>
            </div>
        </div>
    </div>

    <div id="floatingIndicator" class="floating-indicator hidden"></div>

    <script>
        class VoiceChat {
            constructor() {
                this.websocket = null;
                this.mediaStream = null;
                this.audioContext = null;
                this.processor = null;
                this.isRecording = false;
                this.isConnected = false;
                this.autoScroll = true;
                this.volumeAnalyser = null;
                this.volumeDataArray = null;
                
                // é…ç½®å­˜å‚¨é”®å
                this.storageKeys = {
                    proxyUrl: 'voiceChat_proxyUrl',
                    appId: 'voiceChat_appId',
                    accessToken: 'voiceChat_accessToken',
                    autoScroll: 'voiceChat_autoScroll',
                    selectedMicrophone: 'voiceChat_selectedMicrophone',
                    selectedSpeaker: 'voiceChat_selectedSpeaker'
                };
                
                // éŸ³é¢‘è®¾å¤‡ç›¸å…³
                this.audioDevices = {
                    microphones: [],
                    speakers: []
                };
                this.selectedMicrophoneId = null;
                this.selectedSpeakerId = null;
                
                this.initializeUI();
                this.loadConfiguration();
                this.bindEvents();
            }

            async initializeUI() {
                this.updateUI();
                await this.loadAudioDevices();
                this.log('ğŸš€ è±†åŒ…AIè¯­éŸ³é€šè¯ç³»ç»Ÿå·²åŠ è½½', 'info');
            }

            loadConfiguration() {
                // åŠ è½½ä¿å­˜çš„é…ç½®
                try {
                    const proxyUrl = localStorage.getItem(this.storageKeys.proxyUrl);
                    const appId = localStorage.getItem(this.storageKeys.appId);
                    const accessToken = localStorage.getItem(this.storageKeys.accessToken);
                    const autoScroll = localStorage.getItem(this.storageKeys.autoScroll);
                    
                    let hasConfig = false;
                    
                    if (proxyUrl) {
                        document.getElementById('proxyUrl').value = proxyUrl;
                        hasConfig = true;
                    }
                    if (appId) {
                        document.getElementById('appId').value = appId;
                        hasConfig = true;
                    }
                    if (accessToken) {
                        document.getElementById('accessToken').value = accessToken;
                        hasConfig = true;
                    }
                    if (autoScroll !== null) {
                        this.autoScroll = autoScroll === 'true';
                        document.getElementById('autoScrollText').textContent = 
                            `è‡ªåŠ¨æ»šåŠ¨: ${this.autoScroll ? 'å¼€' : 'å…³'}`;
                        hasConfig = true;
                    }
                    
                    // åŠ è½½éŸ³é¢‘è®¾å¤‡é€‰æ‹©
                    const selectedMicrophone = localStorage.getItem(this.storageKeys.selectedMicrophone);
                    const selectedSpeaker = localStorage.getItem(this.storageKeys.selectedSpeaker);
                    
                    if (selectedMicrophone) {
                        this.selectedMicrophoneId = selectedMicrophone;
                        hasConfig = true;
                    }
                    if (selectedSpeaker) {
                        this.selectedSpeakerId = selectedSpeaker;
                        hasConfig = true;
                    }
                    
                    this.updateConfigStatus(hasConfig);
                    
                    if (hasConfig) {
                        this.log('ğŸ“¥ å·²åŠ è½½ä¿å­˜çš„é…ç½®', 'info');
                    }
                } catch (error) {
                    this.log('âš ï¸ åŠ è½½é…ç½®å¤±è´¥: ' + error.message, 'warning');
                    this.updateConfigStatus(false);
                }
            }

            saveConfiguration() {
                // ä¿å­˜å½“å‰é…ç½®
                try {
                    const proxyUrl = document.getElementById('proxyUrl').value;
                    const appId = document.getElementById('appId').value;
                    const accessToken = document.getElementById('accessToken').value;
                    
                    if (proxyUrl) {
                        localStorage.setItem(this.storageKeys.proxyUrl, proxyUrl);
                    }
                    if (appId) {
                        localStorage.setItem(this.storageKeys.appId, appId);
                    }
                    if (accessToken) {
                        localStorage.setItem(this.storageKeys.accessToken, accessToken);
                    }
                    localStorage.setItem(this.storageKeys.autoScroll, this.autoScroll.toString());
                    
                    // ä¿å­˜éŸ³é¢‘è®¾å¤‡é€‰æ‹©
                    if (this.selectedMicrophoneId) {
                        localStorage.setItem(this.storageKeys.selectedMicrophone, this.selectedMicrophoneId);
                    }
                    if (this.selectedSpeakerId) {
                        localStorage.setItem(this.storageKeys.selectedSpeaker, this.selectedSpeakerId);
                    }
                    
                    this.updateConfigStatus(true);
                    this.log('ğŸ’¾ é…ç½®å·²ä¿å­˜', 'success');
                } catch (error) {
                    this.log('âŒ ä¿å­˜é…ç½®å¤±è´¥: ' + error.message, 'error');
                    this.updateConfigStatus(false);
                }
            }

            clearConfiguration() {
                // æ¸…é™¤ä¿å­˜çš„é…ç½®
                try {
                    Object.values(this.storageKeys).forEach(key => {
                        localStorage.removeItem(key);
                    });
                    
                    // é‡ç½®è¡¨å•
                    document.getElementById('proxyUrl').value = 'ws://localhost:8765';
                    document.getElementById('appId').value = '';
                    document.getElementById('accessToken').value = '';
                    
                    this.updateConfigStatus(false);
                    this.log('ğŸ—‘ï¸ é…ç½®å·²æ¸…é™¤', 'info');
                } catch (error) {
                    this.log('âŒ æ¸…é™¤é…ç½®å¤±è´¥: ' + error.message, 'error');
                }
            }

            updateConfigStatus(hasSavedConfig) {
                // æ›´æ–°é…ç½®çŠ¶æ€æŒ‡ç¤ºå™¨
                const statusElement = document.getElementById('configStatus');
                if (hasSavedConfig) {
                    statusElement.className = 'config-status saved';
                    statusElement.textContent = 'âœ… å·²ä¿å­˜';
                    statusElement.title = 'é…ç½®å·²ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨';
                } else {
                    statusElement.className = 'config-status unsaved';
                    statusElement.textContent = 'âš ï¸ æœªä¿å­˜';
                    statusElement.title = 'é…ç½®å°šæœªä¿å­˜';
                }
            }

            async loadAudioDevices() {
                // åŠ è½½éŸ³é¢‘è®¾å¤‡åˆ—è¡¨
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    
                    this.audioDevices.microphones = devices.filter(device => 
                        device.kind === 'audioinput' && device.deviceId !== 'default'
                    );
                    this.audioDevices.speakers = devices.filter(device => 
                        device.kind === 'audiooutput' && device.deviceId !== 'default'
                    );
                    
                    this.updateDeviceSelectors();
                    this.log(`ğŸ§ æ£€æµ‹åˆ° ${this.audioDevices.microphones.length} ä¸ªéº¦å…‹é£ï¼Œ${this.audioDevices.speakers.length} ä¸ªæ‰¬å£°å™¨`, 'info');
                    
                } catch (error) {
                    this.log(`âŒ åŠ è½½éŸ³é¢‘è®¾å¤‡å¤±è´¥: ${error.message}`, 'error');
                    // å³ä½¿å¤±è´¥ä¹Ÿè¦åˆå§‹åŒ–é€‰æ‹©å™¨
                    this.updateDeviceSelectors();
                }
            }

            updateDeviceSelectors() {
                // æ›´æ–°è®¾å¤‡é€‰æ‹©å™¨
                const micSelect = document.getElementById('microphoneSelect');
                const speakerSelect = document.getElementById('speakerSelect');
                
                // æ¸…ç©ºç°æœ‰é€‰é¡¹
                micSelect.innerHTML = '<option value="">é€‰æ‹©éº¦å…‹é£...</option>';
                speakerSelect.innerHTML = '<option value="">é€‰æ‹©æ‰¬å£°å™¨...</option>';
                
                // æ·»åŠ éº¦å…‹é£é€‰é¡¹
                this.audioDevices.microphones.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `éº¦å…‹é£ ${device.deviceId.substring(0, 8)}...`;
                    if (device.deviceId === this.selectedMicrophoneId) {
                        option.selected = true;
                    }
                    micSelect.appendChild(option);
                });
                
                // æ·»åŠ æ‰¬å£°å™¨é€‰é¡¹
                this.audioDevices.speakers.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `æ‰¬å£°å™¨ ${device.deviceId.substring(0, 8)}...`;
                    if (device.deviceId === this.selectedSpeakerId) {
                        option.selected = true;
                    }
                    speakerSelect.appendChild(option);
                });
                
                // å¦‚æœæ²¡æœ‰é€‰ä¸­çš„è®¾å¤‡ï¼Œè‡ªåŠ¨é€‰æ‹©ç¬¬ä¸€ä¸ª
                if (!this.selectedMicrophoneId && this.audioDevices.microphones.length > 0) {
                    this.selectedMicrophoneId = this.audioDevices.microphones[0].deviceId;
                    micSelect.value = this.selectedMicrophoneId;
                }
                
                if (!this.selectedSpeakerId && this.audioDevices.speakers.length > 0) {
                    this.selectedSpeakerId = this.audioDevices.speakers[0].deviceId;
                    speakerSelect.value = this.selectedSpeakerId;
                }
            }

            async refreshAudioDevices() {
                // åˆ·æ–°éŸ³é¢‘è®¾å¤‡åˆ—è¡¨
                this.log('ğŸ”„ æ­£åœ¨åˆ·æ–°éŸ³é¢‘è®¾å¤‡åˆ—è¡¨...', 'info');
                
                try {
                    // è¯·æ±‚æƒé™ä»¥è·å–è®¾å¤‡æ ‡ç­¾
                    await navigator.mediaDevices.getUserMedia({ audio: true });
                    await this.loadAudioDevices();
                    this.log('âœ… éŸ³é¢‘è®¾å¤‡åˆ—è¡¨å·²åˆ·æ–°', 'success');
                } catch (error) {
                    this.log(`âŒ åˆ·æ–°è®¾å¤‡åˆ—è¡¨å¤±è´¥: ${error.message}`, 'error');
                }
            }

            onMicrophoneChange() {
                // éº¦å…‹é£é€‰æ‹©å˜åŒ–
                const micSelect = document.getElementById('microphoneSelect');
                this.selectedMicrophoneId = micSelect.value;
                
                if (this.selectedMicrophoneId) {
                    const device = this.audioDevices.microphones.find(d => d.deviceId === this.selectedMicrophoneId);
                    const deviceName = device ? (device.label || 'æœªçŸ¥è®¾å¤‡') : 'æœªçŸ¥è®¾å¤‡';
                    this.log(`ğŸ¤ å·²é€‰æ‹©éº¦å…‹é£: ${deviceName}`, 'info');
                    this.saveConfiguration();
                }
            }

            onSpeakerChange() {
                // æ‰¬å£°å™¨é€‰æ‹©å˜åŒ–
                const speakerSelect = document.getElementById('speakerSelect');
                this.selectedSpeakerId = speakerSelect.value;
                
                if (this.selectedSpeakerId) {
                    const device = this.audioDevices.speakers.find(d => d.deviceId === this.selectedSpeakerId);
                    const deviceName = device ? (device.label || 'æœªçŸ¥è®¾å¤‡') : 'æœªçŸ¥è®¾å¤‡';
                    this.log(`ğŸ”Š å·²é€‰æ‹©æ‰¬å£°å™¨: ${deviceName}`, 'info');
                    this.saveConfiguration();
                }
            }

            async testSpeaker() {
                // æµ‹è¯•æ‰¬å£°å™¨
                if (!this.selectedSpeakerId) {
                    this.log('âš ï¸ è¯·å…ˆé€‰æ‹©æ‰¬å£°å™¨è®¾å¤‡', 'warning');
                    return;
                }

                try {
                    this.log('ğŸ”” æ­£åœ¨æµ‹è¯•æ‰¬å£°å™¨...', 'info');
                    
                    // åˆ›å»ºæµ‹è¯•éŸ³é¢‘ä¸Šä¸‹æ–‡
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // åˆ›å»º1ç§’çš„æµ‹è¯•éŸ³è°ƒ (440Hz)
                    const duration = 0.5;
                    const sampleRate = audioContext.sampleRate;
                    const buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
                    const channelData = buffer.getChannelData(0);
                    
                    for (let i = 0; i < channelData.length; i++) {
                        channelData[i] = Math.sin(2 * Math.PI * 440 * i / sampleRate) * 0.3;
                    }
                    
                    const source = audioContext.createBufferSource();
                    source.buffer = buffer;
                    source.connect(audioContext.destination);
                    
                    // å¦‚æœæ”¯æŒï¼Œè®¾ç½®è¾“å‡ºè®¾å¤‡
                    if (audioContext.destination.setSinkId) {
                        await audioContext.destination.setSinkId(this.selectedSpeakerId);
                    }
                    
                    source.start();
                    
                    this.log('âœ… æ‰¬å£°å™¨æµ‹è¯•å®Œæˆ', 'success');
                    
                } catch (error) {
                    this.log(`âŒ æ‰¬å£°å™¨æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                }
            }

            bindEvents() {
                // å›è½¦å‘é€æ¶ˆæ¯
                document.getElementById('messageInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.sendMessage();
                    }
                });

                // é…ç½®å­—æ®µå˜åŒ–æ—¶è‡ªåŠ¨ä¿å­˜
                const configInputs = ['proxyUrl', 'appId', 'accessToken'];
                configInputs.forEach(inputId => {
                    const input = document.getElementById(inputId);
                    input.addEventListener('blur', () => {
                        this.saveConfiguration();
                    });
                    input.addEventListener('input', () => {
                        // å»¶è¿Ÿä¿å­˜ï¼Œé¿å…é¢‘ç¹æ“ä½œ
                        clearTimeout(this.saveTimeout);
                        this.saveTimeout = setTimeout(() => {
                            this.saveConfiguration();
                        }, 1000);
                    });
                });

                // éŸ³é¢‘è®¾å¤‡é€‰æ‹©å™¨äº‹ä»¶
                document.getElementById('microphoneSelect').addEventListener('change', () => {
                    this.onMicrophoneChange();
                });
                
                document.getElementById('speakerSelect').addEventListener('change', () => {
                    this.onSpeakerChange();
                });

                // é¡µé¢å¸è½½å‰ä¿å­˜é…ç½®
                window.addEventListener('beforeunload', () => {
                    this.saveConfiguration();
                    this.disconnect();
                });

                // å®šæœŸå¿ƒè·³
                setInterval(() => {
                    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                        this.websocket.send(JSON.stringify({type: 'ping'}));
                    }
                }, 30000);
            }

            log(message, type = 'info') {
                const logElement = document.getElementById('logDisplay');
                const timestamp = new Date().toLocaleTimeString();
                const logMessage = `[${timestamp}] ${message}\n`;
                
                logElement.textContent += logMessage;
                
                if (this.autoScroll) {
                    logElement.scrollTop = logElement.scrollHeight;
                }
                
                console.log(`[${type.toUpperCase()}] ${message}`);
                
                // æ˜¾ç¤ºæµ®åŠ¨æŒ‡ç¤ºå™¨
                this.showFloatingIndicator(message, type);
            }

            showFloatingIndicator(message, type) {
                const indicator = document.getElementById('floatingIndicator');
                const colors = {
                    'info': '#17a2b8',
                    'success': '#28a745',
                    'warning': '#ffc107',
                    'error': '#dc3545'
                };
                
                indicator.style.background = colors[type] || colors.info;
                indicator.textContent = message;
                indicator.classList.remove('hidden');
                
                setTimeout(() => {
                    indicator.classList.add('hidden');
                }, 3000);
            }

            clearLog() {
                document.getElementById('logDisplay').textContent = '';
                this.log('æ—¥å¿—å·²æ¸…ç©º', 'info');
            }

            toggleAutoScroll() {
                this.autoScroll = !this.autoScroll;
                document.getElementById('autoScrollText').textContent = 
                    `è‡ªåŠ¨æ»šåŠ¨: ${this.autoScroll ? 'å¼€' : 'å…³'}`;
                this.log(`è‡ªåŠ¨æ»šåŠ¨å·²${this.autoScroll ? 'å¯ç”¨' : 'ç¦ç”¨'}`, 'info');
                // ä¿å­˜è‡ªåŠ¨æ»šåŠ¨è®¾ç½®
                this.saveConfiguration();
            }

            updateUI() {
                document.getElementById('connectBtn').disabled = this.isConnected;
                document.getElementById('disconnectBtn').disabled = !this.isConnected;
                document.getElementById('voiceButton').disabled = !this.isConnected;
                
                const voiceButton = document.getElementById('voiceButton');
                if (this.isRecording) {
                    voiceButton.className = 'voice-button recording';
                    voiceButton.textContent = 'ğŸ›‘';
                } else {
                    voiceButton.className = 'voice-button idle';
                    voiceButton.textContent = 'ğŸ¤';
                }
            }

            updateConnectionStatus(status, message) {
                const statusElement = document.getElementById('connectionStatus');
                statusElement.className = `status-indicator status-${status}`;
                statusElement.textContent = message;
            }

            async connect() {
                const proxyUrl = document.getElementById('proxyUrl').value;
                const appId = document.getElementById('appId').value;
                const accessToken = document.getElementById('accessToken').value;

                if (!appId || !accessToken) {
                    alert('è¯·å¡«å†™App IDå’ŒAccess Token');
                    return;
                }

                try {
                    this.updateConnectionStatus('connecting', 'ğŸŸ¡ è¿æ¥ä¸­...');
                    this.log('ğŸ”„ å¼€å§‹è¿æ¥ä»£ç†æœåŠ¡å™¨...', 'info');

                    this.websocket = new WebSocket(proxyUrl);

                    this.websocket.onopen = () => {
                        this.log('âœ… WebSocketè¿æ¥æˆåŠŸï¼Œå‘é€è®¤è¯ä¿¡æ¯...', 'success');
                        
                        const authMessage = {
                            type: 'auth',
                            app_id: appId,
                            access_token: accessToken
                        };
                        this.websocket.send(JSON.stringify(authMessage));
                    };

                    this.websocket.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleMessage(data);
                        } catch (e) {
                            this.log(`âŒ è§£ææ¶ˆæ¯å¤±è´¥: ${e.message}`, 'error');
                        }
                    };

                    this.websocket.onclose = () => {
                        this.isConnected = false;
                        this.updateConnectionStatus('disconnected', 'ğŸ”´ è¿æ¥æ–­å¼€');
                        this.log('ğŸ”Œ WebSocketè¿æ¥å·²æ–­å¼€', 'warning');
                        this.updateUI();
                    };

                    this.websocket.onerror = (error) => {
                        this.log(`âŒ WebSocketé”™è¯¯: ${error}`, 'error');
                        this.updateConnectionStatus('disconnected', 'ğŸ”´ è¿æ¥é”™è¯¯');
                        this.updateUI();
                    };

                } catch (error) {
                    this.log(`âŒ è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                    this.updateConnectionStatus('disconnected', 'ğŸ”´ è¿æ¥å¤±è´¥');
                    this.updateUI();
                }
            }

            handleMessage(data) {
                switch (data.type) {
                    case 'auth_success':
                        this.isConnected = true;
                        this.updateConnectionStatus('connected', 'ğŸŸ¢ å·²è¿æ¥');
                        this.log(`ğŸ‰ è®¤è¯æˆåŠŸï¼Œä¼šè¯ID: ${data.session_id.substring(0, 8)}...`, 'success');
                        this.updateUI();
                        break;
                    
                    case 'audio':
                        const audioData = new Uint8Array(
                            data.data.match(/.{1,2}/g).map(byte => parseInt(byte, 16))
                        );
                        this.playAudio(audioData);
                        this.addMessage('AI', 'ğŸ”Š [è¯­éŸ³å›å¤]', true);
                        break;
                    
                    case 'event':
                        this.log(`ğŸ“¢ æ”¶åˆ°äº‹ä»¶: ${data.event} - ${JSON.stringify(data.data)}`, 'info');
                        break;
                    
                    case 'error':
                        this.log(`âŒ æœåŠ¡å™¨é”™è¯¯: ${data.message}`, 'error');
                        break;
                    
                    case 'pong':
                        this.log('ğŸ’“ æ”¶åˆ°å¿ƒè·³å›å¤', 'info');
                        break;
                    
                    default:
                        this.log(`â“ æœªçŸ¥æ¶ˆæ¯ç±»å‹: ${data.type}`, 'warning');
                }
            }

            disconnect() {
                if (this.websocket) {
                    this.websocket.close();
                    this.websocket = null;
                }
                
                if (this.isRecording) {
                    this.stopRecording();
                }
                
                this.isConnected = false;
                this.updateConnectionStatus('disconnected', 'ğŸ”´ æœªè¿æ¥');
                this.updateUI();
                this.log('ğŸ”Œ å·²æ–­å¼€è¿æ¥', 'info');
            }

            async toggleRecording() {
                if (this.isRecording) {
                    this.stopRecording();
                } else {
                    await this.startRecording();
                }
            }

            async startRecording() {
                try {
                    this.log('ğŸ¤ è¯·æ±‚éº¦å…‹é£æƒé™...', 'info');
                    
                    // æ„å»ºéŸ³é¢‘çº¦æŸï¼ŒåŒ…æ‹¬è®¾å¤‡ID
                    const audioConstraints = {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    };
                    
                    // å¦‚æœé€‰æ‹©äº†ç‰¹å®šéº¦å…‹é£ï¼Œæ·»åŠ è®¾å¤‡IDçº¦æŸ
                    if (this.selectedMicrophoneId) {
                        audioConstraints.deviceId = { exact: this.selectedMicrophoneId };
                        
                        const device = this.audioDevices.microphones.find(d => d.deviceId === this.selectedMicrophoneId);
                        const deviceName = device ? (device.label || 'æœªçŸ¥è®¾å¤‡') : 'é€‰å®šè®¾å¤‡';
                        this.log(`ğŸ¤ ä½¿ç”¨éº¦å…‹é£: ${deviceName}`, 'info');
                    }
                    
                    this.mediaStream = await navigator.mediaDevices.getUserMedia({
                        audio: audioConstraints
                    });

                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 16000
                    });

                    const source = this.audioContext.createMediaStreamSource(this.mediaStream);
                    
                    // åˆ›å»ºéŸ³é¢‘å¤„ç†èŠ‚ç‚¹
                    this.processor = this.audioContext.createScriptProcessor(4096, 1, 1);
                    
                    // åˆ›å»ºéŸ³é‡åˆ†æå™¨
                    this.volumeAnalyser = this.audioContext.createAnalyser();
                    this.volumeAnalyser.fftSize = 256;
                    this.volumeDataArray = new Uint8Array(this.volumeAnalyser.frequencyBinCount);
                    
                    source.connect(this.volumeAnalyser);
                    source.connect(this.processor);
                    this.processor.connect(this.audioContext.destination);

                    // éŸ³é¢‘æ•°æ®å¤„ç†
                    this.processor.onaudioprocess = (event) => {
                        if (!this.isRecording || !this.websocket || this.websocket.readyState !== WebSocket.OPEN) {
                            return;
                        }

                        const inputBuffer = event.inputBuffer;
                        const inputData = inputBuffer.getChannelData(0);
                        
                        // è½¬æ¢ä¸º16ä½PCM
                        const pcmData = new Int16Array(inputData.length);
                        for (let i = 0; i < inputData.length; i++) {
                            pcmData[i] = Math.max(-32768, Math.min(32767, inputData[i] * 32768));
                        }

                        // å‘é€éŸ³é¢‘æ•°æ®
                        const message = {
                            type: 'audio',
                            data: Array.from(new Uint8Array(pcmData.buffer))
                                .map(byte => byte.toString(16).padStart(2, '0'))
                                .join('')
                        };
                        this.websocket.send(JSON.stringify(message));
                    };

                    this.isRecording = true;
                    this.updateUI();
                    this.startVolumeMonitoring();
                    this.log('ğŸ™ï¸ å¼€å§‹å½•éŸ³', 'success');
                    this.addMessage('User', 'ğŸ¤ [å¼€å§‹è¯­éŸ³è¾“å…¥]');

                } catch (error) {
                    this.log(`âŒ å¯åŠ¨å½•éŸ³å¤±è´¥: ${error.message}`, 'error');
                }
            }

            stopRecording() {
                if (this.processor) {
                    this.processor.disconnect();
                    this.processor = null;
                }

                if (this.audioContext) {
                    this.audioContext.close();
                    this.audioContext = null;
                }

                if (this.mediaStream) {
                    this.mediaStream.getTracks().forEach(track => track.stop());
                    this.mediaStream = null;
                }

                this.isRecording = false;
                this.updateUI();
                
                // é‡ç½®éŸ³é‡æ˜¾ç¤º
                document.getElementById('volumeBar').style.width = '0%';
                document.getElementById('volumeText').textContent = '0%';
                
                this.log('ğŸ›‘ åœæ­¢å½•éŸ³', 'info');
                this.addMessage('User', 'ğŸ¤ [è¯­éŸ³è¾“å…¥ç»“æŸ]');
            }

            startVolumeMonitoring() {
                const updateVolume = () => {
                    if (!this.isRecording || !this.volumeAnalyser) return;
                    
                    this.volumeAnalyser.getByteFrequencyData(this.volumeDataArray);
                    const average = this.volumeDataArray.reduce((sum, value) => sum + value, 0) / this.volumeDataArray.length;
                    const percentage = Math.round((average / 255) * 100);
                    
                    document.getElementById('volumeBar').style.width = `${percentage}%`;
                    document.getElementById('volumeText').textContent = `${percentage}%`;
                    
                    requestAnimationFrame(updateVolume);
                };
                updateVolume();
            }

            async playAudio(audioData) {
                try {
                    if (!this.audioContext) {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }

                    // å¦‚æœé€‰æ‹©äº†ç‰¹å®šæ‰¬å£°å™¨ï¼Œå°è¯•è®¾ç½®è¾“å‡ºè®¾å¤‡
                    if (this.selectedSpeakerId && this.audioContext.destination.setSinkId) {
                        try {
                            await this.audioContext.destination.setSinkId(this.selectedSpeakerId);
                        } catch (error) {
                            this.log(`âš ï¸ è®¾ç½®æ‰¬å£°å™¨å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤è®¾å¤‡: ${error.message}`, 'warning');
                        }
                    }

                    // å‡è®¾æ¥æ”¶åˆ°çš„æ˜¯PCMæ•°æ®ï¼Œè½¬æ¢ä¸ºAudioBuffer
                    const buffer = this.audioContext.createBuffer(1, audioData.length / 2, 24000);
                    const channelData = buffer.getChannelData(0);
                    
                    // å°†å­—èŠ‚æ•°æ®è½¬æ¢ä¸ºæµ®ç‚¹æ•°
                    for (let i = 0; i < channelData.length; i++) {
                        const sample = (audioData[i * 2] | (audioData[i * 2 + 1] << 8));
                        channelData[i] = sample / 32768.0;
                    }

                    const source = this.audioContext.createBufferSource();
                    source.buffer = buffer;
                    source.connect(this.audioContext.destination);
                    source.start();

                    this.log(`ğŸ”Š æ’­æ”¾éŸ³é¢‘: ${audioData.length} å­—èŠ‚`, 'info');

                } catch (error) {
                    this.log(`âŒ æ’­æ”¾éŸ³é¢‘å¤±è´¥: ${error.message}`, 'error');
                }
            }

            sendMessage() {
                const messageInput = document.getElementById('messageInput');
                const message = messageInput.value.trim();
                
                if (!message) {
                    alert('è¯·è¾“å…¥æ¶ˆæ¯å†…å®¹');
                    return;
                }

                if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {
                    alert('è¯·å…ˆè¿æ¥æœåŠ¡å™¨');
                    return;
                }

                const textMessage = {
                    type: 'text',
                    content: message
                };

                this.websocket.send(JSON.stringify(textMessage));
                this.addMessage('User', message);
                this.log(`ğŸ“¤ å‘é€æ–‡æœ¬æ¶ˆæ¯: ${message}`, 'info');
                messageInput.value = '';
            }

            addMessage(sender, content, isAudio = false) {
                const conversationDisplay = document.getElementById('conversationDisplay');
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${sender.toLowerCase()}`;
                
                const time = new Date().toLocaleTimeString();
                messageDiv.innerHTML = `
                    <div>${content}</div>
                    <div class="message-time">${time}</div>
                `;
                
                conversationDisplay.appendChild(messageDiv);
                conversationDisplay.scrollTop = conversationDisplay.scrollHeight;
            }
        }

        // å…¨å±€å®ä¾‹
        let voiceChat;

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            voiceChat = new VoiceChat();
        });

        // å‘åå…¼å®¹çš„å…¨å±€å‡½æ•°
        function connect() { voiceChat.connect(); }
        function disconnect() { voiceChat.disconnect(); }
        function toggleRecording() { voiceChat.toggleRecording(); }
        function sendMessage() { voiceChat.sendMessage(); }
        function clearLog() { voiceChat.clearLog(); }
        function toggleAutoScroll() { voiceChat.toggleAutoScroll(); }
        function saveConfiguration() { voiceChat.saveConfiguration(); }
        function clearConfiguration() { 
            if (confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰ä¿å­˜çš„é…ç½®å—ï¼Ÿ')) {
                voiceChat.clearConfiguration(); 
            }
        }
        function refreshAudioDevices() { voiceChat.refreshAudioDevices(); }
        function testSpeaker() { voiceChat.testSpeaker(); }
    </script>
</body>
</html>