<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è±†åŒ…AIè¯­éŸ³é€šè¯ - æµè§ˆå™¨ç‰ˆ</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .app-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 1000px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            grid-template-areas: 
                "header header"
                "connection voice"
                "message message"
                "log log";
        }

        .app-header {
            grid-area: header;
            text-align: center;
            margin-bottom: 20px;
        }

        .app-title {
            font-size: 2em;
            color: #333;
            margin-bottom: 8px;
        }

        .app-subtitle {
            color: #666;
            font-size: 1.1em;
        }

        .connection-section {
            grid-area: connection;
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
        }

        .section-title {
            font-size: 1.1em;
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
        }

        .config-group {
            margin-bottom: 15px;
        }

        .config-label {
            display: block;
            font-weight: 600;
            color: #555;
            margin-bottom: 8px;
        }

        .config-input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .config-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .status-indicator {
            padding: 12px 20px;
            border-radius: 10px;
            font-weight: 600;
            text-align: center;
            margin: 15px 0;
            transition: all 0.3s;
        }

        .status-disconnected {
            background: #fee;
            color: #c33;
            border: 2px solid #fcc;
        }

        .status-connecting {
            background: #fff3cd;
            color: #856404;
            border: 2px solid #ffeaa7;
        }

        .status-connected {
            background: #d4edda;
            color: #155724;
            border: 2px solid #c3e6cb;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            flex: 1;
            min-width: 120px;
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-danger {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }

        .btn-success {
            background: linear-gradient(45deg, #51cf66, #40c057);
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(81, 207, 102, 0.4);
        }

        .voice-section {
            grid-area: voice;
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
        }

        .voice-controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .voice-button-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            margin: 0 auto;
        }

        .voice-button-wrapper {
            position: relative;
            width: 100px;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .volume-ring {
            position: absolute;
            top: 0;
            left: 0;
            width: 100px;
            height: 100px;
            z-index: 1;
        }

        .voice-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: none;
            font-size: 2em;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            z-index: 2;
        }

        .volume-text {
            font-size: 14px;
            color: #666;
            font-weight: 600;
        }

        .voice-button.recording {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
            animation: pulse 1.5s infinite;
        }

        .voice-button.idle {
            background: linear-gradient(45deg, #51cf66, #40c057);
            color: white;
        }

        .voice-button:disabled {
            background: #ccc;
            color: #999;
            cursor: not-allowed;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }


        .message-section {
            grid-area: message;
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
        }

        .message-input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .message-input {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 16px;
        }

        .conversation-display {
            background: white;
            border-radius: 10px;
            padding: 15px;
            min-height: 120px;
            max-height: 200px;
            overflow-y: auto;
            border: 2px solid #e9ecef;
        }

        .message {
            margin-bottom: 15px;
            padding: 10px 15px;
            border-radius: 10px;
            max-width: 80%;
        }

        .message.user {
            background: #667eea;
            color: white;
            margin-left: auto;
        }

        .message.ai {
            background: #e9ecef;
            color: #333;
        }

        .message-time {
            font-size: 0.8em;
            opacity: 0.7;
            margin-top: 5px;
        }

        .log-section {
            grid-area: log;
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
        }

        .log-display {
            background: #2d3748;
            color: #e2e8f0;
            border-radius: 10px;
            padding: 15px;
            height: 180px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.3;
        }

        .log-controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }

        .floating-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: 600;
            z-index: 1000;
            transition: all 0.3s;
        }

        .floating-indicator.hidden {
            opacity: 0;
            transform: translateY(-20px);
        }

        .config-status {
            font-size: 0.8em;
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: normal;
            margin-left: 10px;
        }

        .config-status.saved {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .config-status.unsaved {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .audio-device-section {
            background: #f1f3f4;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid #e0e0e0;
        }

        .device-row {
            margin-bottom: 15px;
        }

        .device-row:last-child {
            margin-bottom: 0;
        }

        .device-two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .device-combo {
            display: flex;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            overflow: hidden;
            background: white;
            transition: border-color 0.3s;
        }

        .device-combo:focus-within {
            border-color: #667eea;
        }

        .device-select-combo {
            flex: 1;
            padding: 8px 12px;
            border: none;
            font-size: 14px;
            background: transparent;
            cursor: pointer;
            outline: none;
        }

        .device-select-combo:disabled {
            background: #f8f9fa;
            color: #6c757d;
            cursor: not-allowed;
        }

        .btn-combo {
            padding: 8px 12px;
            border: none;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 40px;
            border-left: 1px solid #e9ecef;
        }

        .btn-combo:hover:not(:disabled) {
            opacity: 0.8;
        }

        .btn-combo:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-combo.btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-combo.btn-success {
            background: #51cf66;
            color: white;
        }

        .device-row-inline {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .device-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .device-group-inline {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            min-width: 200px;
        }

        .device-label {
            min-width: 100px;
            font-weight: 600;
            color: #555;
            font-size: 14px;
        }

        .device-label-inline {
            font-size: 16px;
            min-width: 20px;
        }

        .device-select {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        .device-select-inline {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            transition: border-color 0.3s;
            min-width: 150px;
        }

        .device-actions {
            display: flex;
            gap: 8px;
        }

        .device-select:focus {
            outline: none;
            border-color: #667eea;
        }

        .device-select:disabled {
            background: #f8f9fa;
            color: #6c757d;
            cursor: not-allowed;
        }

        .btn-small {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 40px;
        }

        .btn-small:hover:not(:disabled) {
            transform: translateY(-1px);
        }

        .btn-small:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .audio-volume-control {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
            border: 1px solid #e9ecef;
        }

        .volume-label {
            display: block;
            font-weight: 600;
            color: #555;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .volume-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e9ecef;
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.3s;
        }

        .volume-slider::-webkit-slider-thumb:hover {
            background: #5a6fd8;
            transform: scale(1.1);
        }

        .volume-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        @media (max-width: 768px) {
            .app-container {
                width: 95%;
                padding: 15px;
                grid-template-columns: 1fr;
                grid-template-areas: 
                    "header"
                    "connection"
                    "voice"
                    "message"
                    "log";
            }

            .button-group {
                flex-direction: column;
            }

            .btn {
                min-width: auto;
            }

            .voice-button {
                width: 70px;
                height: 70px;
                font-size: 1.8em;
            }

            .volume-text {
                font-size: 11px;
            }

            .device-two-column {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 12px;
            }

            .device-row-inline {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
            }

            .device-group-inline {
                min-width: auto;
            }

            .device-actions {
                justify-content: center;
            }

            .device-group {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }

            .device-label {
                min-width: auto;
                font-size: 13px;
            }

            .audio-device-section {
                padding: 12px;
            }

            .log-display {
                height: 150px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="app-header">
            <h1 class="app-title">ğŸ¤– è±†åŒ…AIè¯­éŸ³é€šè¯</h1>
            <p class="app-subtitle">é«˜è´¨é‡å®æ—¶è¯­éŸ³å¯¹è¯ä½“éªŒ</p>
        </div>

        <!-- è¿æ¥é…ç½® -->
        <div class="connection-section">
            <h3 class="section-title">ğŸ”§ è¿æ¥é…ç½® <span id="configStatus" class="config-status"></span></h3>
            
            <div class="config-group">
                <label class="config-label">ä»£ç†æœåŠ¡å™¨åœ°å€</label>
                <input type="text" id="proxyUrl" class="config-input" value="ws://localhost:8765" placeholder="ws://localhost:8765">
            </div>
            
            <div class="config-group">
                <label class="config-label">App ID</label>
                <input type="text" id="appId" class="config-input" placeholder="è¯·è¾“å…¥ç«å±±å¼•æ“App ID">
            </div>
            
            <div class="config-group">
                <label class="config-label">Access Token</label>
                <input type="password" id="accessToken" class="config-input" placeholder="è¯·è¾“å…¥ç«å±±å¼•æ“Access Token">
            </div>

            <div class="button-group">
                <button id="connectionToggleBtn" class="btn btn-primary" onclick="toggleConnection()">è¿æ¥</button>
            </div>
        </div>

        <!-- è¯­éŸ³æ§åˆ¶ -->
        <div class="voice-section">
            <h3 class="section-title">ğŸ¤ è¯­éŸ³å¯¹è¯</h3>
            
            <!-- éŸ³é¢‘è®¾å¤‡é€‰æ‹© -->
            <div class="audio-device-section">
                <div class="device-two-column">
                    <div class="device-combo">
                        <select id="microphoneSelect" class="device-select-combo">
                            <option value="">ğŸ¤ é€‰æ‹©éº¦å…‹é£...</option>
                        </select>
                        <button class="btn-combo btn-primary" onclick="refreshAudioDevices()" title="åˆ·æ–°è®¾å¤‡åˆ—è¡¨">ğŸ”„</button>
                    </div>
                    <div class="device-combo">
                        <select id="speakerSelect" class="device-select-combo">
                            <option value="">ğŸ”Š é€‰æ‹©æ‰¬å£°å™¨...</option>
                        </select>
                        <button class="btn-combo btn-success" onclick="testSpeaker()" title="æµ‹è¯•æ‰¬å£°å™¨">ğŸ””</button>
                    </div>
                </div>
            </div>
            
            <div class="voice-controls">
                <div class="voice-button-container">
                    <div class="voice-button-wrapper">
                        <svg class="volume-ring" width="100" height="100">
                            <circle cx="50" cy="50" r="45" fill="none" stroke="#e9ecef" stroke-width="4"></circle>
                            <circle id="volumeRing" cx="50" cy="50" r="45" fill="none" stroke="#51cf66" stroke-width="4" 
                                    stroke-linecap="round" stroke-dasharray="283" stroke-dashoffset="283" 
                                    transform="rotate(-90 50 50)" style="transition: stroke-dashoffset 0.1s ease;"></circle>
                        </svg>
                        <button id="voiceButton" class="voice-button idle" onclick="toggleRecording()" disabled>
                            ğŸ¤
                        </button>
                    </div>
                    <span id="volumeText" class="volume-text">0%</span>
                </div>
                
                <div class="audio-volume-control">
                    <label class="volume-label">ğŸ”Š AIè¯­éŸ³éŸ³é‡: <span id="aiVolumeText">30%</span></label>
                    <input type="range" id="aiVolumeSlider" class="volume-slider" 
                           min="0" max="100" value="30" 
                           title="è°ƒèŠ‚AIè¯­éŸ³æ’­æ”¾éŸ³é‡">
                </div>
            </div>
        </div>

        <!-- æ–‡æœ¬æ¶ˆæ¯ -->
        <div class="message-section">
            <h3 class="section-title">ğŸ’¬ å¯¹è¯è®°å½•</h3>
            
            <div class="message-input-group">
                <input type="text" id="messageInput" class="message-input" placeholder="è¾“å…¥æ–‡æœ¬æ¶ˆæ¯..." value="ä»°å¤©å¤§ç¬‘å‡ºé—¨å»">
                <button class="btn btn-primary" onclick="sendMessage()">å‘é€</button>
            </div>
            
            <div id="conversationDisplay" class="conversation-display"></div>
        </div>

        <!-- æ—¥å¿— -->
        <div class="log-section">
            <h3 class="section-title">ğŸ“‹ ç³»ç»Ÿæ—¥å¿—</h3>
            <div id="logDisplay" class="log-display"></div>
            <div class="log-controls">
                <button class="btn btn-primary" onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
                <button class="btn btn-primary" onclick="copyLog()">ğŸ“‹ å¤åˆ¶æ—¥å¿—</button>
                <button class="btn btn-primary" onclick="toggleAutoScroll()">
                    <span id="autoScrollText">è‡ªåŠ¨æ»šåŠ¨: å¼€</span>
                </button>
            </div>
        </div>
    </div>

    <div id="floatingIndicator" class="floating-indicator hidden"></div>

    <script>
        class VoiceChat {
            constructor() {
                this.websocket = null;
                this.mediaStream = null;
                this.audioContext = null;
                this.processor = null; 
                this.isRecording = false;
                this.isConnected = false;
                this.autoScroll = true;
                this.volumeAnalyser = null;
                this.volumeDataArray = null;
                this.microphonePermission = null; // éº¦å…‹é£æƒé™çŠ¶æ€
                
                // æµå¼éŸ³é¢‘æ’­æ”¾
                this.audioStream = null;
                this.audioBuffers = [];
                this.currentPlayTime = 0;
                this.currentAudioSources = []; // è·Ÿè¸ªæ­£åœ¨æ’­æ”¾çš„éŸ³é¢‘æº
                
                // æ‰¬å£°å™¨åˆ‡æ¢æ”¯æŒ
                this.audioElement = null;
                this.mediaStreamDestination = null;
                
                // é…ç½®å­˜å‚¨é”®å
                this.storageKeys = {
                    proxyUrl: 'voiceChat_proxyUrl',
                    appId: 'voiceChat_appId',
                    accessToken: 'voiceChat_accessToken',
                    autoScroll: 'voiceChat_autoScroll',
                    selectedMicrophone: 'voiceChat_selectedMicrophone',
                    selectedSpeaker: 'voiceChat_selectedSpeaker',
                    aiVolume: 'voiceChat_aiVolume'
                };
                
                // éŸ³é¢‘è®¾å¤‡ç›¸å…³
                this.audioDevices = {
                    microphones: [],
                    speakers: []
                };
                this.selectedMicrophoneId = null;
                this.selectedSpeakerId = null;
                this.aiVolume = 0.3; // é»˜è®¤30%éŸ³é‡
                
                this.initializeUI();
                this.loadConfiguration();
                this.bindEvents();
            }

            async initializeUI() {
                this.updateUI();
                await this.loadAudioDevices();
                this.log('ğŸš€ è±†åŒ…AIè¯­éŸ³é€šè¯ç³»ç»Ÿå·²åŠ è½½', 'info');
            }

            loadConfiguration() {
                // åŠ è½½ä¿å­˜çš„é…ç½®
                try {
                    const proxyUrl = localStorage.getItem(this.storageKeys.proxyUrl);
                    const appId = localStorage.getItem(this.storageKeys.appId);
                    const accessToken = localStorage.getItem(this.storageKeys.accessToken);
                    const autoScroll = localStorage.getItem(this.storageKeys.autoScroll);
                    
                    let hasConfig = false;
                    
                    if (proxyUrl) {
                        document.getElementById('proxyUrl').value = proxyUrl;
                        hasConfig = true;
                    }
                    if (appId) {
                        document.getElementById('appId').value = appId;
                        hasConfig = true;
                    }
                    if (accessToken) {
                        document.getElementById('accessToken').value = accessToken;
                        hasConfig = true;
                    }
                    if (autoScroll !== null) {
                        this.autoScroll = autoScroll === 'true';
                        document.getElementById('autoScrollText').textContent = 
                            `è‡ªåŠ¨æ»šåŠ¨: ${this.autoScroll ? 'å¼€' : 'å…³'}`;
                        hasConfig = true;
                    }
                    
                    // åŠ è½½éŸ³é¢‘è®¾å¤‡é€‰æ‹©
                    const selectedMicrophone = localStorage.getItem(this.storageKeys.selectedMicrophone);
                    const selectedSpeaker = localStorage.getItem(this.storageKeys.selectedSpeaker);
                    
                    if (selectedMicrophone) {
                        this.selectedMicrophoneId = selectedMicrophone;
                        hasConfig = true;
                    }
                    if (selectedSpeaker) {
                        this.selectedSpeakerId = selectedSpeaker;
                        hasConfig = true;
                    }
                    
                    // åŠ è½½AIéŸ³é‡è®¾ç½®
                    const aiVolume = localStorage.getItem(this.storageKeys.aiVolume);
                    if (aiVolume !== null) {
                        this.aiVolume = parseFloat(aiVolume);
                        document.getElementById('aiVolumeSlider').value = this.aiVolume * 100;
                        document.getElementById('aiVolumeText').textContent = `${Math.round(this.aiVolume * 100)}%`;
                        hasConfig = true;
                    }
                    
                    this.updateConfigStatus(hasConfig);
                    
                    if (hasConfig) {
                        this.log('ğŸ“¥ å·²åŠ è½½ä¿å­˜çš„é…ç½®', 'info');
                    }
                } catch (error) {
                    this.log('âš ï¸ åŠ è½½é…ç½®å¤±è´¥: ' + error.message, 'warning');
                    this.updateConfigStatus(false);
                }
            }

            saveConfiguration() {
                // ä¿å­˜å½“å‰é…ç½®
                try {
                    const proxyUrl = document.getElementById('proxyUrl').value;
                    const appId = document.getElementById('appId').value;
                    const accessToken = document.getElementById('accessToken').value;
                    
                    if (proxyUrl) {
                        localStorage.setItem(this.storageKeys.proxyUrl, proxyUrl);
                    }
                    if (appId) {
                        localStorage.setItem(this.storageKeys.appId, appId);
                    }
                    if (accessToken) {
                        localStorage.setItem(this.storageKeys.accessToken, accessToken);
                    }
                    localStorage.setItem(this.storageKeys.autoScroll, this.autoScroll.toString());
                    
                    // ä¿å­˜éŸ³é¢‘è®¾å¤‡é€‰æ‹©
                    if (this.selectedMicrophoneId) {
                        localStorage.setItem(this.storageKeys.selectedMicrophone, this.selectedMicrophoneId);
                    }
                    if (this.selectedSpeakerId) {
                        localStorage.setItem(this.storageKeys.selectedSpeaker, this.selectedSpeakerId);
                    }
                    
                    // ä¿å­˜AIéŸ³é‡è®¾ç½®
                    localStorage.setItem(this.storageKeys.aiVolume, this.aiVolume.toString());
                    
                    this.updateConfigStatus(true);
                    this.log('ğŸ’¾ é…ç½®å·²ä¿å­˜', 'success');
                } catch (error) {
                    this.log('âŒ ä¿å­˜é…ç½®å¤±è´¥: ' + error.message, 'error');
                    this.updateConfigStatus(false);
                }
            }

            clearConfiguration() {
                // æ¸…é™¤ä¿å­˜çš„é…ç½®
                try {
                    Object.values(this.storageKeys).forEach(key => {
                        localStorage.removeItem(key);
                    });
                    
                    // é‡ç½®è¡¨å•
                    document.getElementById('proxyUrl').value = 'ws://localhost:8765';
                    document.getElementById('appId').value = '';
                    document.getElementById('accessToken').value = '';
                    
                    this.updateConfigStatus(false);
                    this.log('ğŸ—‘ï¸ é…ç½®å·²æ¸…é™¤', 'info');
                } catch (error) {
                    this.log('âŒ æ¸…é™¤é…ç½®å¤±è´¥: ' + error.message, 'error');
                }
            }

            updateConfigStatus(hasSavedConfig) {
                // æ›´æ–°é…ç½®çŠ¶æ€æŒ‡ç¤ºå™¨
                const statusElement = document.getElementById('configStatus');
                if (hasSavedConfig) {
                    statusElement.className = 'config-status saved';
                    statusElement.textContent = 'âœ… å·²ä¿å­˜';
                    statusElement.title = 'é…ç½®å·²ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨';
                } else {
                    statusElement.className = 'config-status unsaved';
                    statusElement.textContent = 'âš ï¸ æœªä¿å­˜';
                    statusElement.title = 'é…ç½®å°šæœªä¿å­˜';
                }
            }

            async loadAudioDevices() {
                // åŠ è½½éŸ³é¢‘è®¾å¤‡åˆ—è¡¨
                try {
                    // å…ˆè¯·æ±‚éº¦å…‹é£æƒé™ä»¥è·å–è®¾å¤‡æ ‡ç­¾
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        stream.getTracks().forEach(track => track.stop()); // ç«‹å³åœæ­¢æµ
                        this.log('ğŸ¤ éº¦å…‹é£æƒé™å·²è·å–', 'success');
                    } catch (permissionError) {
                        this.log(`âš ï¸ éº¦å…‹é£æƒé™è¯·æ±‚å¤±è´¥: ${permissionError.message}`, 'warning');
                        this.log('ğŸ“ è®¾å¤‡æ ‡ç­¾å¯èƒ½æ— æ³•æ­£å¸¸æ˜¾ç¤º', 'info');
                    }
                    
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    
                    this.audioDevices.microphones = devices.filter(device => 
                        device.kind === 'audioinput' && device.deviceId !== 'default'
                    );
                    this.audioDevices.speakers = devices.filter(device => 
                        device.kind === 'audiooutput' && device.deviceId !== 'default'
                    );
                    
                    this.updateDeviceSelectors();
                    this.log(`ğŸ§ æ£€æµ‹åˆ° ${this.audioDevices.microphones.length} ä¸ªéº¦å…‹é£ï¼Œ${this.audioDevices.speakers.length} ä¸ªæ‰¬å£°å™¨`, 'info');
                    
                } catch (error) {
                    this.log(`âŒ åŠ è½½éŸ³é¢‘è®¾å¤‡å¤±è´¥: ${error.message}`, 'error');
                    // å³ä½¿å¤±è´¥ä¹Ÿè¦åˆå§‹åŒ–é€‰æ‹©å™¨
                    this.updateDeviceSelectors();
                }
            }

            updateDeviceSelectors() {
                // æ›´æ–°è®¾å¤‡é€‰æ‹©å™¨
                const micSelect = document.getElementById('microphoneSelect');
                const speakerSelect = document.getElementById('speakerSelect');
                
                // æ¸…ç©ºç°æœ‰é€‰é¡¹
                micSelect.innerHTML = '<option value="">é€‰æ‹©éº¦å…‹é£...</option>';
                speakerSelect.innerHTML = '<option value="">é€‰æ‹©æ‰¬å£°å™¨...</option>';
                
                // æ·»åŠ éº¦å…‹é£é€‰é¡¹
                this.audioDevices.microphones.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `éº¦å…‹é£ ${device.deviceId.substring(0, 8)}...`;
                    if (device.deviceId === this.selectedMicrophoneId) {
                        option.selected = true;
                    }
                    micSelect.appendChild(option);
                });
                
                // æ·»åŠ æ‰¬å£°å™¨é€‰é¡¹
                this.audioDevices.speakers.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `æ‰¬å£°å™¨ ${device.deviceId.substring(0, 8)}...`;
                    if (device.deviceId === this.selectedSpeakerId) {
                        option.selected = true;
                    }
                    speakerSelect.appendChild(option);
                });
                
                // å¦‚æœæ²¡æœ‰é€‰ä¸­çš„è®¾å¤‡ï¼Œè‡ªåŠ¨é€‰æ‹©ç¬¬ä¸€ä¸ª
                if (!this.selectedMicrophoneId && this.audioDevices.microphones.length > 0) {
                    this.selectedMicrophoneId = this.audioDevices.microphones[0].deviceId;
                    micSelect.value = this.selectedMicrophoneId;
                }
                
                if (!this.selectedSpeakerId && this.audioDevices.speakers.length > 0) {
                    this.selectedSpeakerId = this.audioDevices.speakers[0].deviceId;
                    speakerSelect.value = this.selectedSpeakerId;
                }
            }

            async refreshAudioDevices() {
                // åˆ·æ–°éŸ³é¢‘è®¾å¤‡åˆ—è¡¨
                this.log('ğŸ”„ æ­£åœ¨åˆ·æ–°éŸ³é¢‘è®¾å¤‡åˆ—è¡¨...', 'info');
                
                try {
                    // è¯·æ±‚æƒé™ä»¥è·å–è®¾å¤‡æ ‡ç­¾
                    await navigator.mediaDevices.getUserMedia({ audio: true });
                    await this.loadAudioDevices();
                    this.log('âœ… éŸ³é¢‘è®¾å¤‡åˆ—è¡¨å·²åˆ·æ–°', 'success');
                } catch (error) {
                    this.log(`âŒ åˆ·æ–°è®¾å¤‡åˆ—è¡¨å¤±è´¥: ${error.message}`, 'error');
                }
            }

            onMicrophoneChange() {
                // éº¦å…‹é£é€‰æ‹©å˜åŒ–
                const micSelect = document.getElementById('microphoneSelect');
                this.selectedMicrophoneId = micSelect.value;
                
                if (this.selectedMicrophoneId) {
                    const device = this.audioDevices.microphones.find(d => d.deviceId === this.selectedMicrophoneId);
                    const deviceName = device ? (device.label || 'æœªçŸ¥è®¾å¤‡') : 'æœªçŸ¥è®¾å¤‡';
                    this.log(`ğŸ¤ å·²é€‰æ‹©éº¦å…‹é£: ${deviceName}`, 'info');
                    this.saveConfiguration();
                }
            }

            onSpeakerChange() {
                // æ‰¬å£°å™¨é€‰æ‹©å˜åŒ–
                const speakerSelect = document.getElementById('speakerSelect');
                this.selectedSpeakerId = speakerSelect.value;
                
                if (this.selectedSpeakerId) {
                    const device = this.audioDevices.speakers.find(d => d.deviceId === this.selectedSpeakerId);
                    const deviceName = device ? (device.label || 'æœªçŸ¥è®¾å¤‡') : 'æœªçŸ¥è®¾å¤‡';
                    this.log(`ğŸ”Š å·²é€‰æ‹©æ‰¬å£°å™¨: ${deviceName}`, 'info');
                    this.saveConfiguration();
                }
            }

            async testSpeaker() {
                // æµ‹è¯•æ‰¬å£°å™¨
                if (!this.selectedSpeakerId) {
                    this.log('âš ï¸ è¯·å…ˆé€‰æ‹©æ‰¬å£°å™¨è®¾å¤‡', 'warning');
                    return;
                }

                try {
                    this.log('ğŸ”” æ­£åœ¨æµ‹è¯•æ‰¬å£°å™¨...', 'info');
                    
                    // åˆ›å»ºæµ‹è¯•éŸ³é¢‘ä¸Šä¸‹æ–‡
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // åˆ›å»º1ç§’çš„æµ‹è¯•éŸ³è°ƒ (440Hz)
                    const duration = 0.5;
                    const sampleRate = audioContext.sampleRate;
                    const buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
                    const channelData = buffer.getChannelData(0);
                    
                    for (let i = 0; i < channelData.length; i++) {
                        channelData[i] = Math.sin(2 * Math.PI * 440 * i / sampleRate) * 0.3;
                    }
                    
                    const source = audioContext.createBufferSource();
                    source.buffer = buffer;
                    source.connect(audioContext.destination);
                    
                    // å¦‚æœæ”¯æŒï¼Œè®¾ç½®è¾“å‡ºè®¾å¤‡
                    if (audioContext.destination.setSinkId) {
                        await audioContext.destination.setSinkId(this.selectedSpeakerId);
                    }
                    
                    source.start();
                    
                    this.log('âœ… æ‰¬å£°å™¨æµ‹è¯•å®Œæˆ', 'success');
                    
                } catch (error) {
                    this.log(`âŒ æ‰¬å£°å™¨æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                }
            }

            onAIVolumeChange(value) {
                // AIéŸ³é‡å˜åŒ–å¤„ç†
                this.aiVolume = parseFloat(value) / 100;
                document.getElementById('aiVolumeText').textContent = `${value}%`;
                
                this.log(`ğŸ”Š AIè¯­éŸ³éŸ³é‡è°ƒèŠ‚ä¸º: ${value}%`, 'info');
                
                // å»¶è¿Ÿä¿å­˜ï¼Œé¿å…é¢‘ç¹æ“ä½œ
                clearTimeout(this.volumeTimeout);
                this.volumeTimeout = setTimeout(() => {
                    this.saveConfiguration();
                }, 500);
            }

            bindEvents() {
                // å›è½¦å‘é€æ¶ˆæ¯
                document.getElementById('messageInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.sendMessage();
                    }
                });

                // é…ç½®å­—æ®µå˜åŒ–æ—¶è‡ªåŠ¨ä¿å­˜
                const configInputs = ['proxyUrl', 'appId', 'accessToken'];
                configInputs.forEach(inputId => {
                    const input = document.getElementById(inputId);
                    input.addEventListener('blur', () => {
                        this.saveConfiguration();
                    });
                    input.addEventListener('input', () => {
                        // å»¶è¿Ÿä¿å­˜ï¼Œé¿å…é¢‘ç¹æ“ä½œ
                        clearTimeout(this.saveTimeout);
                        this.saveTimeout = setTimeout(() => {
                            this.saveConfiguration();
                        }, 1000);
                    });
                });

                // éŸ³é¢‘è®¾å¤‡é€‰æ‹©å™¨äº‹ä»¶
                document.getElementById('microphoneSelect').addEventListener('change', () => {
                    this.onMicrophoneChange();
                });
                
                document.getElementById('speakerSelect').addEventListener('change', () => {
                    this.onSpeakerChange();
                });

                // AIéŸ³é‡æ»‘å—äº‹ä»¶
                document.getElementById('aiVolumeSlider').addEventListener('input', (e) => {
                    this.onAIVolumeChange(e.target.value);
                });

                // é¡µé¢å¸è½½å‰ä¿å­˜é…ç½®
                window.addEventListener('beforeunload', () => {
                    this.saveConfiguration();
                    this.disconnect();
                });

                // å®šæœŸå¿ƒè·³
                setInterval(() => {
                    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                        this.websocket.send(JSON.stringify({type: 'ping'}));
                    }
                }, 30000);
            }

            log(message, type = 'info') {
                const logElement = document.getElementById('logDisplay');
                const timestamp = new Date().toLocaleTimeString();
                const logMessage = `[${timestamp}] ${message}\n`;
                
                logElement.textContent += logMessage;
                
                if (this.autoScroll) {
                    logElement.scrollTop = logElement.scrollHeight;
                }
                
                console.log(`[${type.toUpperCase()}] ${message}`);
                
                // æ˜¾ç¤ºæµ®åŠ¨æŒ‡ç¤ºå™¨
                this.showFloatingIndicator(message, type);
            }

            showFloatingIndicator(message, type) {
                const indicator = document.getElementById('floatingIndicator');
                const colors = {
                    'info': '#17a2b8',
                    'success': '#28a745',
                    'warning': '#ffc107',
                    'error': '#dc3545'
                };
                
                indicator.style.background = colors[type] || colors.info;
                indicator.textContent = message;
                indicator.classList.remove('hidden');
                
                setTimeout(() => {
                    indicator.classList.add('hidden');
                }, 3000);
            }

            clearLog() {
                document.getElementById('logDisplay').textContent = '';
                this.log('æ—¥å¿—å·²æ¸…ç©º', 'info');
            }

            async copyLog() {
                try {
                    const logDisplay = document.getElementById('logDisplay');
                    
                    // ç›´æ¥è·å–æ—¥å¿—æ˜¾ç¤ºåŒºåŸŸçš„æ–‡æœ¬å†…å®¹
                    const logText = logDisplay.textContent || '';
                    
                    if (!logText.trim()) {
                        alert('æ²¡æœ‰æ—¥å¿—å†…å®¹å¯å¤åˆ¶');
                        return;
                    }
                    
                    // æ·»åŠ å¤´éƒ¨ä¿¡æ¯
                    const header = `è±†åŒ…AIè¯­éŸ³é€šè¯ç³»ç»Ÿ - æ—¥å¿—å¯¼å‡º\næ—¶é—´: ${new Date().toLocaleString()}\n${'='.repeat(50)}\n\n`;
                    const fullLogText = header + logText;
                    
                    // ä½¿ç”¨Clipboard APIå¤åˆ¶åˆ°å‰ªè´´æ¿
                    if (navigator.clipboard && window.isSecureContext) {
                        await navigator.clipboard.writeText(fullLogText);
                        this.log('ğŸ“‹ æ—¥å¿—å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
                    } else {
                        // å›é€€æ–¹æ¡ˆï¼šä½¿ç”¨ä¼ ç»Ÿæ–¹æ³•
                        const textArea = document.createElement('textarea');
                        textArea.value = fullLogText;
                        textArea.style.position = 'fixed';
                        textArea.style.left = '-999999px';
                        textArea.style.top = '-999999px';
                        document.body.appendChild(textArea);
                        textArea.focus();
                        textArea.select();
                        
                        try {
                            document.execCommand('copy');
                            this.log('ğŸ“‹ æ—¥å¿—å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
                        } catch (err) {
                            this.log('âŒ å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©æ—¥å¿—æ–‡æœ¬', 'error');
                        }
                        
                        document.body.removeChild(textArea);
                    }
                    
                } catch (error) {
                    this.log(`âŒ å¤åˆ¶æ—¥å¿—å¤±è´¥: ${error.message}`, 'error');
                }
            }

            toggleAutoScroll() {
                this.autoScroll = !this.autoScroll;
                document.getElementById('autoScrollText').textContent = 
                    `è‡ªåŠ¨æ»šåŠ¨: ${this.autoScroll ? 'å¼€' : 'å…³'}`;
                this.log(`è‡ªåŠ¨æ»šåŠ¨å·²${this.autoScroll ? 'å¯ç”¨' : 'ç¦ç”¨'}`, 'info');
                // ä¿å­˜è‡ªåŠ¨æ»šåŠ¨è®¾ç½®
                this.saveConfiguration();
            }

            async updateUI() {
                const connectionBtn = document.getElementById('connectionToggleBtn');
                if (this.isConnected) {
                    connectionBtn.textContent = 'æ–­å¼€è¿æ¥';
                    connectionBtn.className = 'btn btn-danger';
                } else {
                    connectionBtn.textContent = 'è¿æ¥';
                    connectionBtn.className = 'btn btn-primary';
                }
                
                // æ£€æŸ¥éº¦å…‹é£æƒé™çŠ¶æ€
                await this.checkMicrophonePermission();
                
                // å½•éŸ³æŒ‰é’®å¯ç”¨æ¡ä»¶ï¼šä»…éœ€è¦éº¦å…‹é£æƒé™ï¼Œä¸ä¾èµ–è¿æ¥çŠ¶æ€
                const canRecord = this.microphonePermission !== 'denied';
                console.log(`å½•éŸ³çŠ¶æ€ï¼š`, {isConnected: this.isConnected, microphonePermission: this.microphonePermission, canRecord})
                document.getElementById('voiceButton').disabled = !canRecord;
                
                // éŸ³é¢‘è®¾å¤‡åŠŸèƒ½å®Œå…¨ç‹¬ç«‹äºè¿æ¥çŠ¶æ€
                // - å½•éŸ³ï¼šå¯ä»¥ç¦»çº¿æµ‹è¯•éº¦å…‹é£
                // - åˆ·æ–°è®¾å¤‡ï¼šå§‹ç»ˆå¯ç”¨
                // - æ‰¬å£°å™¨æµ‹è¯•ï¼šä»…éœ€è¦é€‰æ‹©äº†è®¾å¤‡
                
                const voiceButton = document.getElementById('voiceButton');
                if (this.isRecording) {
                    voiceButton.className = 'voice-button recording';
                    voiceButton.textContent = 'ğŸ›‘';
                } else {
                    voiceButton.className = 'voice-button idle';
                    voiceButton.textContent = 'ğŸ¤';
                }
                
                // æ˜¾ç¤ºæƒé™çŠ¶æ€æç¤ºï¼ˆä¸ä¾èµ–è¿æ¥çŠ¶æ€ï¼‰
                if (!canRecord) {
                    if (this.microphonePermission === 'denied') {
                        this.log('âš ï¸ éº¦å…‹é£æƒé™è¢«æ‹’ç»ï¼Œæ— æ³•ä½¿ç”¨å½•éŸ³åŠŸèƒ½', 'warning');
                    }
                } else if (this.microphonePermission === 'prompt') {
                    this.log('ğŸ“ ç‚¹å‡»å½•éŸ³æŒ‰é’®æ—¶å°†è¯·æ±‚éº¦å…‹é£æƒé™', 'info');
                }
            }

            async checkMicrophonePermission() {
                // æ£€æŸ¥éº¦å…‹é£æƒé™çŠ¶æ€
                try {
                    if (navigator.permissions) {
                        const permission = await navigator.permissions.query({ name: 'microphone' });
                        this.microphonePermission = permission.state;
                        
                        // ç›‘å¬æƒé™å˜åŒ–
                        permission.onchange = () => {
                            this.microphonePermission = permission.state;
                            this.updateUI();
                        };
                    } else {
                        // å¯¹äºä¸æ”¯æŒpermissions APIçš„æµè§ˆå™¨ï¼Œå‡è®¾éœ€è¦ç”¨æˆ·æˆæƒ
                        this.microphonePermission = 'prompt';
                    }
                } catch (error) {
                    this.log(`âš ï¸ æ— æ³•æ£€æŸ¥éº¦å…‹é£æƒé™: ${error.message}`, 'warning');
                    this.microphonePermission = 'prompt';
                }
            }

            updateConnectionStatus(status, message) {
                const statusElement = document.getElementById('connectionStatus');
                statusElement.className = `status-indicator status-${status}`;
                statusElement.textContent = message;
            }

            async connect() {
                const proxyUrl = document.getElementById('proxyUrl').value;
                const appId = document.getElementById('appId').value;
                const accessToken = document.getElementById('accessToken').value;

                if (!appId || !accessToken) {
                    alert('è¯·å¡«å†™App IDå’ŒAccess Token');
                    return;
                }

                try {
                    this.updateConnectionStatus('connecting', 'ğŸŸ¡ è¿æ¥ä¸­...');
                    this.log('ğŸ”„ å¼€å§‹è¿æ¥ä»£ç†æœåŠ¡å™¨...', 'info');

                    this.websocket = new WebSocket(proxyUrl);

                    this.websocket.onopen = () => {
                        this.isConnected = true;
                        this.updateConnectionStatus('connected', 'ğŸŸ¢ å·²è¿æ¥');
                        this.updateUI();
                        this.initAudioStream(); // åˆå§‹åŒ–éŸ³é¢‘æµ
                    };

                    this.websocket.binaryType = 'arraybuffer'; // å¼ºåˆ¶ä½¿ç”¨ArrayBuffer
                    
                    this.websocket.onmessage = (event) => {
                        try {
                            if (event.data instanceof ArrayBuffer) {
                                // ç›´æ¥å¤„ç†äºŒè¿›åˆ¶éŸ³é¢‘æ•°æ®
                                this.handleAudioBinary(event.data);
                            } else if (event.data instanceof Blob) {
                                // è½¬æ¢Blobä¸ºArrayBuffer
                                event.data.arrayBuffer().then(buffer => {
                                    this.handleAudioBinary(buffer);
                                });
                            } else {
                                // å¤„ç†JSONæ¶ˆæ¯
                                const data = JSON.parse(event.data);
                                this.handleMessage(data);
                            }
                        } catch (e) {
                            this.log(`âŒ å¤„ç†æ¶ˆæ¯å¤±è´¥: ${e.message}`, 'error');
                        }
                    };

                    this.websocket.onclose = () => {
                        this.isConnected = false;
                        this.updateConnectionStatus('disconnected', 'ğŸ”´ è¿æ¥æ–­å¼€');
                        this.log('ğŸ”Œ WebSocketè¿æ¥å·²æ–­å¼€', 'warning');
                        this.updateUI();
                    };

                    this.websocket.onerror = (error) => {
                        this.log(`âŒ WebSocketé”™è¯¯: ${error}`, 'error');
                        this.updateConnectionStatus('disconnected', 'ğŸ”´ è¿æ¥é”™è¯¯');
                        this.updateUI();
                    };

                } catch (error) {
                    this.log(`âŒ è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                    this.updateConnectionStatus('disconnected', 'ğŸ”´ è¿æ¥å¤±è´¥');
                    this.updateUI();
                }
            }

            handleMessage(data) {
                switch (data.type) {
                    
                    case 'event':
                        this.handleServerEvent(data.event, data.data);
                        break;
                    
                    case 'error':
                        this.log(`âŒ æœåŠ¡å™¨é”™è¯¯: ${data.message}`, 'error');
                        break;
                    
                    case 'pong':
                        this.log('ğŸ’“ æ”¶åˆ°å¿ƒè·³å›å¤', 'info');
                        break;
                    
                    default:
                        this.log(`â“ æœªçŸ¥æ¶ˆæ¯ç±»å‹: ${data.type}`, 'warning');
                }
            }

            handleServerEvent(event, data) {
                // å¤„ç†æœåŠ¡å™¨äº‹ä»¶ï¼ŒåŒ…æ‹¬è¯­éŸ³æ‰“æ–­é€»è¾‘
                this.log(`ğŸ“¢ æ”¶åˆ°äº‹ä»¶: ${event} - ${JSON.stringify(data)}`, 'info');
                
                // ASR_INFOäº‹ä»¶ï¼šç”¨æˆ·å¼€å§‹è¯´è¯ï¼Œéœ€è¦æ‰“æ–­AIè¯­éŸ³
                if (event === 450) { // protocol.ServerEvent.ASR_INFO
                    this.log('ğŸ›‘ æ£€æµ‹åˆ°ç”¨æˆ·è¯­éŸ³ï¼Œæ‰“æ–­AIæ’­æ”¾', 'warning');
                    this.interruptAIAudio();
                }
            }

            handleAudioBinary(arrayBuffer) {
                // ç›´æ¥å¤„ç†äºŒè¿›åˆ¶éŸ³é¢‘æ•°æ®
                try {
                    this.streamAudioData(arrayBuffer);
                    this.addMessage('AI', 'ğŸ”Š [è¯­éŸ³å›å¤]', true);
                } catch (error) {
                    this.log(`âŒ å¤„ç†éŸ³é¢‘æ•°æ®å¤±è´¥: ${error.message}`, 'error');
                }
            }

            disconnect() {
                if (this.websocket) {
                    this.websocket.close();
                    this.websocket = null;
                }
                
                if (this.isRecording) {
                    this.stopRecording();
                }
                
                // æ¸…ç†éŸ³é¢‘æµ
                this.audioBuffers = [];
                this.currentPlayTime = 0;
                this.interruptAIAudio(); // åœæ­¢æ‰€æœ‰æ­£åœ¨æ’­æ”¾çš„éŸ³é¢‘
                if (this.audioStream) {
                    this.audioStream.disconnect();
                    this.audioStream = null;
                }
                
                // æ¸…ç†éŸ³é¢‘å…ƒç´ 
                if (this.audioElement) {
                    this.audioElement.pause();
                    this.audioElement.srcObject = null;
                    if (this.audioElement.parentNode) {
                        this.audioElement.parentNode.removeChild(this.audioElement);
                    }
                    this.audioElement = null;
                }
                this.mediaStreamDestination = null;
                
                this.isConnected = false;
                this.updateConnectionStatus('disconnected', 'ğŸ”´ æœªè¿æ¥');
                this.updateUI();
                this.log('ğŸ”Œ å·²æ–­å¼€è¿æ¥ï¼ŒéŸ³é¢‘é˜Ÿåˆ—å·²æ¸…ç†', 'info');
            }

            async toggleRecording() {
                if (this.isRecording) {
                    this.stopRecording();
                } else {
                    await this.startRecording();
                }
            }

            async startRecording() {
                try {
                    this.log('ğŸ¤ è¯·æ±‚éº¦å…‹é£æƒé™...', 'info');
                    
                    // æ„å»ºéŸ³é¢‘çº¦æŸï¼ŒåŒ…æ‹¬è®¾å¤‡ID
                    const audioConstraints = {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    };
                    
                    // å¦‚æœé€‰æ‹©äº†ç‰¹å®šéº¦å…‹é£ï¼Œæ·»åŠ è®¾å¤‡IDçº¦æŸ
                    if (this.selectedMicrophoneId) {
                        // ä½¿ç”¨idealè€Œä¸æ˜¯exactï¼Œæä¾›æ›´å¥½çš„å…¼å®¹æ€§
                        audioConstraints.deviceId = { ideal: this.selectedMicrophoneId };
                        
                        const device = this.audioDevices.microphones.find(d => d.deviceId === this.selectedMicrophoneId);
                        const deviceName = device ? (device.label || 'æœªçŸ¥è®¾å¤‡') : 'é€‰å®šè®¾å¤‡';
                        this.log(`ğŸ¤ å°è¯•ä½¿ç”¨éº¦å…‹é£: ${deviceName}`, 'info');
                    } else {
                        // æ²¡æœ‰é€‰æ‹©ç‰¹å®šè®¾å¤‡æ—¶ï¼Œä½¿ç”¨é»˜è®¤è®¾å¤‡
                        this.log(`ğŸ¤ ä½¿ç”¨é»˜è®¤éº¦å…‹é£è®¾å¤‡`, 'info');
                    }
                    
                    this.mediaStream = await navigator.mediaDevices.getUserMedia({
                        audio: audioConstraints
                    });

                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 16000
                    });

                    const source = this.audioContext.createMediaStreamSource(this.mediaStream);
                    
                    // åˆ›å»ºéŸ³é¢‘å¤„ç†èŠ‚ç‚¹
                    this.processor = this.audioContext.createScriptProcessor(4096, 1, 1);
                    
                    // åˆ›å»ºéŸ³é‡åˆ†æå™¨
                    this.volumeAnalyser = this.audioContext.createAnalyser();
                    this.volumeAnalyser.fftSize = 256;
                    this.volumeDataArray = new Uint8Array(this.volumeAnalyser.frequencyBinCount);
                    
                    source.connect(this.volumeAnalyser);
                    source.connect(this.processor);
                    this.processor.connect(this.audioContext.destination);

                    // éŸ³é¢‘æ•°æ®å¤„ç†
                    this.processor.onaudioprocess = (event) => {
                        if (!this.isRecording) {
                            return;
                        }

                        const inputBuffer = event.inputBuffer;
                        const inputData = inputBuffer.getChannelData(0);
                        
                        // å¦‚æœå·²è¿æ¥æœåŠ¡å™¨ï¼Œå‘é€éŸ³é¢‘æ•°æ®
                        if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                            // è½¬æ¢ä¸º16ä½PCM
                            const pcmData = new Int16Array(inputData.length);
                            for (let i = 0; i < inputData.length; i++) {
                                pcmData[i] = Math.max(-32768, Math.min(32767, inputData[i] * 32768));
                            }

                            // å‘é€éŸ³é¢‘æ•°æ®
                            const message = {
                                type: 'audio',
                                data: Array.from(new Uint8Array(pcmData.buffer))
                                    .map(byte => byte.toString(16).padStart(2, '0'))
                                    .join('')
                            };
                            this.websocket.send(JSON.stringify(message));
                        }
                        // å¦‚æœæœªè¿æ¥ï¼Œå½•éŸ³ä»ç„¶å·¥ä½œï¼ˆç”¨äºæµ‹è¯•éº¦å…‹é£ï¼‰
                    };

                    this.isRecording = true;
                    this.updateUI();
                    this.startVolumeMonitoring();
                    if (this.isConnected) {
                        this.log('ğŸ™ï¸ å¼€å§‹å½•éŸ³å¹¶å‘é€åˆ°æœåŠ¡å™¨', 'success');
                        this.addMessage('User', 'ğŸ¤ [å¼€å§‹è¯­éŸ³è¾“å…¥]');
                    } else {
                        this.log('ğŸ™ï¸ å¼€å§‹å½•éŸ³æµ‹è¯•ï¼ˆç¦»çº¿æ¨¡å¼ï¼‰', 'success');
                    }

                } catch (error) {
                    this.log(`âŒ å¯åŠ¨å½•éŸ³å¤±è´¥: ${error.message}`, 'error');
                }
            }

            stopRecording() {
                if (this.processor) {
                    this.processor.disconnect();
                    this.processor = null;
                }

                if (this.audioContext) {
                    this.audioContext.close();
                    this.audioContext = null;
                }

                if (this.mediaStream) {
                    this.mediaStream.getTracks().forEach(track => track.stop());
                    this.mediaStream = null;
                }

                this.isRecording = false;
                this.updateUI();
                
                // é‡ç½®éŸ³é‡æ˜¾ç¤º
                const volumeRing = document.getElementById('volumeRing');
                const volumeText = document.getElementById('volumeText');
                if (volumeRing) {
                    volumeRing.style.strokeDashoffset = '283';
                    volumeRing.style.stroke = '#51cf66';
                }
                if (volumeText) {
                    volumeText.textContent = '0%';
                }
                
                if (this.isConnected) {
                    this.log('ğŸ›‘ åœæ­¢å½•éŸ³', 'info');
                    this.addMessage('User', 'ğŸ¤ [è¯­éŸ³è¾“å…¥ç»“æŸ]');
                } else {
                    this.log('ğŸ›‘ åœæ­¢å½•éŸ³æµ‹è¯•', 'info');
                }
            }

            startVolumeMonitoring() {
                const updateVolume = () => {
                    try {
                        if (!this.isRecording || !this.volumeAnalyser || !this.volumeDataArray) {
                            return;
                        }
                        
                        // æ£€æŸ¥éŸ³é¢‘ä¸Šä¸‹æ–‡çŠ¶æ€
                        if (this.audioContext && this.audioContext.state === 'suspended') {
                            this.audioContext.resume();
                        }
                        
                        this.volumeAnalyser.getByteFrequencyData(this.volumeDataArray);
                        
                        // è®¡ç®—éŸ³é‡å¹³å‡å€¼å’Œå³°å€¼
                        const average = this.volumeDataArray.reduce((sum, value) => sum + value, 0) / this.volumeDataArray.length;
                        const peak = Math.max(...this.volumeDataArray);
                        
                        // ä½¿ç”¨å³°å€¼å’Œå¹³å‡å€¼çš„ç»„åˆæ¥æé«˜æ•æ„Ÿåº¦
                        const volumeLevel = Math.max(average, peak * 0.3);
                        const percentage = Math.round((volumeLevel / 255) * 100);
                        
                        // æ›´æ–°éŸ³é‡ç¯å’Œæ–‡å­—
                        const volumeRing = document.getElementById('volumeRing');
                        const volumeText = document.getElementById('volumeText');
                        
                        if (volumeRing && volumeText) {
                            // è®¡ç®—ç¯å½¢è¿›åº¦ï¼ˆå‘¨é•¿ 283 = 2 * PI * 45ï¼‰
                            const circumference = 283;
                            const offset = circumference - (circumference * percentage / 100);
                            volumeRing.style.strokeDashoffset = offset;
                            
                            // æ ¹æ®éŸ³é‡æ°´å¹³è°ƒæ•´é¢œè‰²
                            if (percentage < 30) {
                                volumeRing.style.stroke = '#51cf66'; // ç»¿è‰²
                            } else if (percentage < 70) {
                                volumeRing.style.stroke = '#ffd43b'; // é»„è‰²
                            } else {
                                volumeRing.style.stroke = '#ff6b6b'; // çº¢è‰²
                            }
                            
                            volumeText.textContent = `${percentage}%`;
                        }
                        
                        // å¦‚æœå½•éŸ³ä¸­ï¼Œç»§ç»­ç›‘æ§
                        if (this.isRecording) {
                            requestAnimationFrame(updateVolume);
                        }
                        
                    } catch (error) {
                        this.log(`âš ï¸ éŸ³é‡ç›‘æ§å¼‚å¸¸: ${error.message}`, 'warning');
                        // å¼‚å¸¸æ—¶åœæ­¢ç›‘æ§ï¼Œé¿å…æ— é™å¾ªç¯é”™è¯¯
                        return;
                    }
                };
                updateVolume();
            }

            initAudioStream() {
                // åˆå§‹åŒ–æµå¼éŸ³é¢‘æ’­æ”¾ç³»ç»Ÿ
                try {
                    if (!this.audioContext) {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    this.log('ğŸµ éŸ³é¢‘æµç³»ç»Ÿå·²åˆå§‹åŒ–', 'info');
                } catch (error) {
                    this.log(`âŒ åˆå§‹åŒ–éŸ³é¢‘æµå¤±è´¥: ${error.message}`, 'error');
                }
            }

            streamAudioData(arrayBuffer) {
                // æµå¼å¤„ç†éŸ³é¢‘æ•°æ®
                try {
                    if (!this.audioContext) {
                        this.initAudioStream();
                    }
                    
                    // ç¡®ä¿AudioContextå·²å¯åŠ¨
                    if (this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }

                    // ç«å±±å¼•æ“è¿”å›24kHz Float32 PCMæ•°æ®
                    const sampleRate = 24000;
                    let samples;
                    
                    // æ£€æŸ¥æ•°æ®é•¿åº¦æ˜¯å¦ä¸º4çš„å€æ•°ï¼ˆFloat32ï¼‰
                    if (arrayBuffer.byteLength % 4 === 0) {
                        samples = new Float32Array(arrayBuffer);
                        this.log(`ğŸ”Š æ¥æ”¶Float32éŸ³é¢‘æµ: ${arrayBuffer.byteLength}å­—èŠ‚ â†’ ${samples.length}é‡‡æ ·ç‚¹`, 'info');
                    } else {
                        // å¤„ç†ä¸è§„åˆ™é•¿åº¦ï¼Œæˆªæ–­åˆ°4å­—èŠ‚è¾¹ç•Œ
                        const validLength = Math.floor(arrayBuffer.byteLength / 4) * 4;
                        if (validLength < 4) {
                            this.log(`âš ï¸ éŸ³é¢‘æ•°æ®è¿‡çŸ­: ${arrayBuffer.byteLength}å­—èŠ‚ï¼Œè·³è¿‡æ’­æ”¾`, 'warning');
                            return;
                        }
                        
                        const validBuffer = arrayBuffer.slice(0, validLength);
                        samples = new Float32Array(validBuffer);
                        this.log(`âš ï¸ éŸ³é¢‘æ•°æ®é•¿åº¦å¼‚å¸¸: ${arrayBuffer.byteLength}å­—èŠ‚ï¼Œæˆªæ–­ä¸º${validLength}å­—èŠ‚å¤„ç†`, 'warning');
                    }
                    
                    // æ£€æŸ¥éŸ³é¢‘æ•°æ®èŒƒå›´
                    const maxValue = Math.max(...samples);
                    const minValue = Math.min(...samples);
                    const avgValue = samples.reduce((sum, val) => sum + Math.abs(val), 0) / samples.length;
                    
                    this.log(`ğŸµ éŸ³é¢‘åˆ†æ: èŒƒå›´[${minValue.toFixed(3)}, ${maxValue.toFixed(3)}], å¹³å‡å¹…åº¦: ${avgValue.toFixed(4)}`, 'info');

                    // åˆ›å»ºAudioBuffer
                    const buffer = this.audioContext.createBuffer(1, samples.length, sampleRate);
                    const channelData = buffer.getChannelData(0);
                    
                    // åº”ç”¨éŸ³é‡å¹¶å¤åˆ¶æ•°æ®
                    for (let i = 0; i < samples.length; i++) {
                        channelData[i] = samples[i] * this.aiVolume;
                    }

                    // ç«‹å³æ’­æ”¾ï¼Œæ— éœ€é˜Ÿåˆ—ç®¡ç†
                    this.playAudioBuffer(buffer);

                } catch (error) {
                    this.log(`âŒ æµå¼éŸ³é¢‘å¤„ç†å¤±è´¥: ${error.message}`, 'error');
                }
            }

            async playAudioBuffer(buffer) {
                // ç›´æ¥æ’­æ”¾AudioBuffer
                try {
                    const source = this.audioContext.createBufferSource();
                    source.buffer = buffer;
                    
                    // æ ¹æ®è®¾å¤‡é€‰æ‹©ç¡®å®šç›®æ ‡
                    let destination = this.audioContext.destination;
                    
                    // å¦‚æœé€‰æ‹©äº†ç‰¹å®šæ‰¬å£°å™¨è®¾å¤‡ï¼Œä½¿ç”¨Audioå…ƒç´ æ’­æ”¾
                    if (this.selectedSpeakerId && this.selectedSpeakerId !== 'default') {
                        // ç¡®ä¿mediaStreamDestinationä¸å½“å‰audioContextåŒ¹é…
                        if (!this.mediaStreamDestination || this.mediaStreamDestination.context !== this.audioContext) {
                            this.mediaStreamDestination = this.audioContext.createMediaStreamDestination();
                            
                            if (!this.audioElement) {
                                this.audioElement = new Audio();
                                this.audioElement.style.display = 'none';
                                document.body.appendChild(this.audioElement);
                            }
                            
                            this.audioElement.srcObject = this.mediaStreamDestination.stream;
                            try {
                                if (this.audioElement.setSinkId) {
                                    await this.audioElement.setSinkId(this.selectedSpeakerId);
                                    this.log(`ğŸ”Š å·²åˆ‡æ¢åˆ°æŒ‡å®šæ‰¬å£°å™¨è®¾å¤‡`, 'info');
                                }
                                this.audioElement.play();
                            } catch (deviceError) {
                                this.log(`âš ï¸ æ‰¬å£°å™¨è®¾å¤‡åˆ‡æ¢å¤±è´¥: ${deviceError.message}ï¼Œä½¿ç”¨é»˜è®¤è®¾å¤‡`, 'warning');
                                destination = this.audioContext.destination;
                            }
                        }
                        
                        if (this.mediaStreamDestination && this.mediaStreamDestination.context === this.audioContext) {
                            destination = this.mediaStreamDestination;
                        }
                    }
                    
                    source.connect(destination);
                    
                    // è®¡ç®—æ’­æ”¾æ—¶é—´ï¼Œå®ç°è¿ç»­æ’­æ”¾
                    const currentTime = this.audioContext.currentTime;
                    const startTime = Math.max(currentTime, this.currentPlayTime);
                    
                    source.start(startTime);
                    this.currentPlayTime = startTime + buffer.duration;
                    
                    // è·Ÿè¸ªæ­£åœ¨æ’­æ”¾çš„éŸ³é¢‘æºï¼Œç”¨äºè¯­éŸ³æ‰“æ–­
                    this.currentAudioSources.push(source);
                    
                    // æ’­æ”¾ç»“æŸåä»è·Ÿè¸ªåˆ—è¡¨ä¸­ç§»é™¤
                    source.onended = () => {
                        const index = this.currentAudioSources.indexOf(source);
                        if (index > -1) {
                            this.currentAudioSources.splice(index, 1);
                        }
                    };
                    
                    this.log(`ğŸµ æµå¼æ’­æ”¾: ${buffer.duration.toFixed(3)}ç§’`, 'info');

                } catch (error) {
                    this.log(`âŒ æ’­æ”¾ç¼“å†²åŒºå¤±è´¥: ${error.message}`, 'error');
                }
            }

            interruptAIAudio() {
                // å®ç°è¯­éŸ³æ‰“æ–­åŠŸèƒ½ï¼šåœæ­¢æ‰€æœ‰æ­£åœ¨æ’­æ”¾çš„AIéŸ³é¢‘
                try {
                    if (this.currentAudioSources.length > 0) {
                        this.log(`ğŸ›‘ æ‰“æ–­AIè¯­éŸ³ï¼šåœæ­¢ ${this.currentAudioSources.length} ä¸ªéŸ³é¢‘æº`, 'warning');
                        
                        // åœæ­¢æ‰€æœ‰æ­£åœ¨æ’­æ”¾çš„éŸ³é¢‘æº
                        this.currentAudioSources.forEach(source => {
                            try {
                                source.stop();
                            } catch (e) {
                                // å¿½ç•¥å·²ç»åœæ­¢çš„éŸ³é¢‘æº
                            }
                        });
                        
                        // æ¸…ç©ºéŸ³é¢‘æºè·Ÿè¸ªåˆ—è¡¨
                        this.currentAudioSources = [];
                        
                        // é‡ç½®æ’­æ”¾æ—¶é—´ï¼Œé¿å…éŸ³é¢‘ç§¯å‹
                        this.currentPlayTime = this.audioContext ? this.audioContext.currentTime : 0;
                        
                        this.log('âœ… AIéŸ³é¢‘å·²æˆåŠŸæ‰“æ–­', 'success');
                    }
                } catch (error) {
                    this.log(`âŒ æ‰“æ–­AIéŸ³é¢‘å¤±è´¥: ${error.message}`, 'error');
                }
            }

            async sendMessage() {
                const messageInput = document.getElementById('messageInput');
                const message = messageInput.value.trim();
                
                if (!message) {
                    alert('è¯·è¾“å…¥æ¶ˆæ¯å†…å®¹');
                    return;
                }

                if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {
                    alert('è¯·å…ˆè¿æ¥æœåŠ¡å™¨');
                    return;
                }

                // æŒ‰ç…§å®˜æ–¹æ–‡æ¡£å‘é€ä¸‰åŒ…ChatTTSTextæ¶ˆæ¯
                await this.sendChatTTSTextInThreePackets(message);
                this.addMessage('User', message);
                this.log(`ğŸ“¤ å‘é€ChatTTSTextæ¶ˆæ¯(ä¸‰åŒ…æ ¼å¼): ${message}`, 'info');
                messageInput.value = '';
            }

            async sendChatTTSTextInThreePackets(fullMessage) {
                try {
                    // å°†æ¶ˆæ¯åˆ†æˆä¸¤éƒ¨åˆ†è¿›è¡Œæ¼”ç¤ºï¼Œå®é™…ä½¿ç”¨ä¸­å¯ä»¥æŒ‰éœ€åˆ†å‰²
                    const midPoint = Math.ceil(fullMessage.length / 2);
                    const firstPart = fullMessage.substring(0, midPoint);
                    const secondPart = fullMessage.substring(midPoint);

                    // ç¬¬ä¸€åŒ…ï¼šå¼€å§‹åŒ…
                    const firstPacket = {
                        type: 'chat_tts_text',
                        start: true,
                        end: false,
                        content: firstPart
                    };
                    this.websocket.send(JSON.stringify(firstPacket));
                    this.log(`ğŸ“¤ å‘é€ç¬¬ä¸€åŒ…: ${firstPacket}`, 'info');
                    
                    // ç­‰å¾…ä¸€ä¸‹ç¡®ä¿åŒ…çš„é¡ºåº
                    await new Promise(resolve => setTimeout(resolve, 10));

                    // ç¬¬äºŒåŒ…ï¼šä¸­é—´åŒ…ï¼ˆå¦‚æœæœ‰ç¬¬äºŒéƒ¨åˆ†å†…å®¹ï¼‰
                    if (secondPart) {
                        const middlePacket = {
                            type: 'chat_tts_text',
                            start: false,
                            end: false,
                            content: secondPart
                        };
                        this.websocket.send(JSON.stringify(middlePacket));
                        this.log(`ğŸ“¤ å‘é€ç¬¬äºŒåŒ…: ${secondPart}`, 'info');
                        
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }

                    // ç¬¬ä¸‰åŒ…ï¼šç»“æŸåŒ…
                    const endPacket = {
                        type: 'chat_tts_text',
                        start: false,
                        end: true,
                        content: ""
                    };
                    this.websocket.send(JSON.stringify(endPacket));
                    this.log(`ğŸ“¤ å‘é€ç¬¬ä¸‰åŒ…: ${endPacket}`, 'info');

                } catch (error) {
                    this.log(`âŒ å‘é€ChatTTSTextå¤±è´¥: ${error.message}`, 'error');
                }
            }

            addMessage(sender, content, isAudio = false) {
                const conversationDisplay = document.getElementById('conversationDisplay');
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${sender.toLowerCase()}`;
                
                const time = new Date().toLocaleTimeString();
                messageDiv.innerHTML = `
                    <div>${content}</div>
                    <div class="message-time">${time}</div>
                `;
                
                conversationDisplay.appendChild(messageDiv);
                conversationDisplay.scrollTop = conversationDisplay.scrollHeight;
            }
        }

        // å…¨å±€å®ä¾‹
        let voiceChat;

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            voiceChat = new VoiceChat();
        });

        // å‘åå…¼å®¹çš„å…¨å±€å‡½æ•°
        function connect() { voiceChat.connect(); }
        function disconnect() { voiceChat.disconnect(); }
        function toggleConnection() { 
            if (voiceChat.isConnected) {
                voiceChat.disconnect();
            } else {
                voiceChat.connect();
            }
        }
        function toggleRecording() { voiceChat.toggleRecording(); }
        function sendMessage() { voiceChat.sendMessage(); }
        function clearLog() { voiceChat.clearLog(); }
        function copyLog() { voiceChat.copyLog(); }
        function toggleAutoScroll() { voiceChat.toggleAutoScroll(); }
        function refreshAudioDevices() { voiceChat.refreshAudioDevices(); }
        function testSpeaker() { voiceChat.testSpeaker(); }
    </script>
</body>
</html>